import{j as L,ag as J,as as Ie,C as Ne,w as _,l as Be,u as ye,aw as Ee,aa as Pe,au as Te}from"./index.3f21dce0.js";import{k as P,e as k,b as E,A as Oe,w as qe,P as Ue,v as R,y as D,i as W,N as je,z as ze,a0 as se,p as Me}from"./vendor.0e7da6ec.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Q(e,n,a){if(a){const o=[],t=e.value;n.forEach(l=>{const r=t.get(l);r&&o.push(r.rawNode)}),L(a,n,o)}}function X(e,n){const a=[],{children:o}=e||{};return o&&o.forEach(t=>{const{key:l}=t;n!=null&&n.includes(l)||a.push(t.key),a.push(...X(t,n))}),a}function Z(e,n,a){const o=[];for(;n&&!P(n.parentKey);){const{parentKey:t}=n;a!=null&&a.includes(n.parentKey)||o.push(t),n=e.get(t)}return o}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function He(e,n){const[a,o]=J(e,"checkedKeys",()=>[]),t=k(()=>{const s=[];return e.checkable&&n.value.forEach((h,d)=>{h.checkDisabled&&s.push(d)}),s}),l=k(()=>e.cascaderStrategy!=="off"?Re(n.value,a.value,t.value):a.value),r=k(()=>{const s=l.value;if(s.length===0||e.cascaderStrategy==="off")return[];const h=new Set,d=t.value,u=n.value;return s.forEach(K=>{const{parentKey:C}=u.get(K)||{};if(!P(C)){let y=u.get(C);if(y&&!s.includes(y.key))for(d.includes(C)||h.add(C);y&&!P(y.parentKey);)d.includes(y.parentKey)||h.add(y.parentKey),y=u.get(y.parentKey)}}),[...h]}),c=s=>{const h=s.key,d=n.value,u=t.value,K=e.cascaderStrategy,C=K!=="off",y=C?X(s,u):[],F=l.value.indexOf(h),w=F>-1;let v=[...l.value];if(w||y.length&&y.every(p=>v.includes(p)||r.value.includes(p))){const p=C?Z(d,s,u):[];v.splice(F,1),v=v.filter(m=>!p.includes(m)&&!y.includes(m))}else v.push(h),C&&ke(d,s,v,u),v.push(...y);g(w,s.rawNode,_e(K,v,d,u))},g=(s,h,d)=>{const{onCheck:u,onCheckedChange:K}=e;L(u,!s,h),o(d),Q(n,d,K)};return{checkedKeys:a,allCheckedKeys:l,checkDisabledKeys:t,indeterminateKeys:r,handleCheck:c}}function ke(e,n,a,o){let t=!0;for(;t&&n&&!P(n.parentKey);){const l=e.get(n.parentKey);l&&!o.includes(n.parentKey)&&(t=l.children.every(r=>o.includes(r.key)||a.includes(r.key)),t&&a.push(n.parentKey)),n=l}}function _e(e,n,a,o){if(e==="off")return[...new Set(n)];let t=[];n=Ke(a,n,o),o.length&&(t=n.filter(l=>o.includes(l)));for(const l of n){const r=a.get(l);if(r){const c=r.key,g=r.parentKey;e==="parent"?n.includes(g)||t.push(c):e==="child"?r.isLeaf&&t.push(c):t.push(c)}}return[...new Set(t)]}function Re(e,n,a){let o=[...n],t;for(const l of n){const r=e.get(l),c=r==null?void 0:r.parentKey,g=X(r,a);o=o.concat(g),!P(c)&&t!==c&&(ke(e,r,o,a),t=c)}return o=Ke(e,[...new Set(o)],a),o}function Ke(e,n,a){let o=[...n];if(a.length){for(const t of a)if(!o.includes(t)){const l=e.get(t),r=Z(e,l,a);o=o.filter(c=>!r.includes(c))}}return o}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Ve(e,n,a,o){const t=k(()=>Ce(e,e.dataSource,n.value,a.value,o.value)),l=k(()=>{const r=new Map;return de(t.value,r),r});return{mergedNodes:t,mergedNodeMap:l}}function Ge(e,{expandedKeys:n},a,o){return k(()=>{const{searchValue:t}=a,l=new Map(n.value.map((c,g)=>[c,g])),r=new Map(o.value.map((c,g)=>[c,g]));return l.size||r.size?Ye(e.value,l,r):t&&!r.size?[]:e.value.map(c=>({...c,expanded:!1,level:0}))})}function Ce(e,n,a,o,t,l,r){const{disabled:c,loadChildren:g}=e,s=P(r)?-1:r;return n.map((h,d)=>De(h,a,o,t,c,!!g,d===0,d===n.length-1,s,l))}function De(e,n,a,o,t,l,r,c,g,s){var v;const h=a(e),{check:d,drag:u,drop:K,select:C}=We(e,t),y=e[n],F=e[o];g++;const w=y==null?void 0:y.map((p,m)=>De(p,n,a,o,t,l,m===0,m===y.length-1,g,h));return{children:w,label:F,key:h,isFirst:r,isLeaf:(v=e.isLeaf)!=null?v:!((w==null?void 0:w.length)||l),isLast:c,parentKey:s,expanded:!1,level:g,rawNode:e,checkDisabled:d,dragDisabled:u,dropDisabled:K,selectDisabled:C}}function We(e,n){const a=e.disabled||{};if(a===!0)return{check:!0,drag:!0,drop:!0,select:!0};let{check:o,drag:t,drop:l,select:r}=a;if(n){const c=n(e)||{};if(c===!0)return{check:!0,drag:!0,drop:!0,select:!0};o=o||c.check,t=t||c.drag,l=l||c.drop,r=r||c.select}return{check:o,drag:t,drop:l,select:r}}function de(e,n){e.forEach(a=>{const{key:o,children:t}=a;n.set(o,a),t&&de(t,n)})}function me(e=[],n){const a=[],o=e.length;return e.forEach((t,l)=>{t.isFirst=l===0,t.isLast=l===o-1,n.has(t.key)||n.size==0?(t.hidden=!1,a.push(t)):t.hidden=!0,me(t.children,n).length>0&&(t.hidden=!1,a.push(t))}),a.length&&(a[0].isFirst=!0,a[a.length-1].isLast=!0),a}function Ye(e,n,a){const o=[],t=[];return me(e,a),e.forEach(l=>{for(t.push(l);t.length;){const r=t.pop();if(r){const{children:c,key:g,hidden:s}=r,h=n.has(g);if(r.expanded=h,!s&&o.push(r),c&&h)for(let d=c.length;d>0;d--)!c[d-1].hidden&&t.push(c[d-1])}}}),o}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Je(e,n,{expandedKeys:a,setExpandedKeys:o}){const t=k(()=>{var f;return(f=e.draggableIcon)!=null?f:n.draggableIcon}),l=E(),r=E(),c=E(),g=E(),s=E();let h;const d=()=>{h&&(clearTimeout(h),h=void 0)};Oe(()=>d());const u=()=>{P(l.value)||(l.value=void 0,r.value=void 0)},K=()=>{P(c.value)||(c.value=void 0,g.value=void 0,s.value=void 0)},C=(f,x)=>{var A,$;return{evt:f,node:x.rawNode,dragNode:(A=l.value)==null?void 0:A.rawNode,dropNode:($=c.value)==null?void 0:$.rawNode,dropType:s.value}},y=f=>{w(f,void 0),window.removeEventListener("dragend",y)},F=(f,x)=>{l.value=x,r.value=X(x),Xe(x.key,a.value,o),window.addEventListener("dragend",y),L(e.onDragstart,C(f,x))},w=(f,x)=>{x&&L(e.onDragend,C(f,x)),u(),K()},v=async(f,x)=>{const A=l.value;if(A){d(),A.key!==x.key&&(h=setTimeout(()=>{var I;l.value&&((I=x.children)==null?void 0:I.length)&&Qe(x.key,a.value,o),h=void 0},1e3));const $=await pe(x,A,r.value,f,e.droppable);$?(c.value=x,g.value=$!=="inside"?x.parentKey:void 0,s.value=$):K()}L(e.onDragenter,C(f,x))},p=async(f,x)=>{const A=l.value;if(A){const $=await pe(x,A,r.value,f,e.droppable);$?(c.value=x,g.value=$!=="inside"?x.parentKey:void 0,s.value=$):K()}L(e.onDragover,C(f,x))},m=(f,x)=>{const A=c.value;(A==null?void 0:A.key)===x.key&&!f.currentTarget.contains(f.relatedTarget)&&K(),L(e.onDragleave,C(f,x))},S=(f,x)=>{s.value||K(),L(e.onDrop,C(f,x)),u(),K()};return{draggableIcon:t,dragKey:k(()=>{var f;return(f=l.value)==null?void 0:f.key}),dropKey:k(()=>{var f;return(f=c.value)==null?void 0:f.key}),dropParentKey:g,dropType:s,handleDragstart:F,handleDragend:w,handleDragenter:v,handleDragover:p,handleDragleave:m,handleDrop:S}}function Qe(e,n,a){n.indexOf(e)===-1&&a([...n,e])}function Xe(e,n,a){const o=n.indexOf(e);if(o!==-1){const t=[...n];t.splice(o,1),a(t)}}async function pe(e,n,a,o,t){const{key:l,children:r=[]}=e;if(n.key===l||a&&a.includes(l))return!1;const{clientY:c}=o,{top:g,height:s}=o.target.getBoundingClientRect(),h=c<g+s/2;let d;if(t){const u={evt:o,isTopHalf:h,dragNode:n.rawNode,dropNode:e.rawNode};d=await t(u)}return(d===void 0||d===!0)&&(r.length>0?d="inside":h?d="before":d="after"),d}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Ze(e,n,a,{expandedKeys:o,handleExpand:t},{activeKey:l,handleSelect:r}){const c=E(!1);return{focused:c,handleFocus:u=>{c.value=!0,L(e.onFocus,u)},handleBlur:u=>{c.value=!0,L(e.onBlur,u)},handleKeydown:u=>{switch(u.code){case"ArrowUp":case"ArrowDown":u.preventDefault()}L(e.onKeydown,u)},handleKeyup:u=>{const K=u.code,C=l.value,y=a.value,F=y.length;if(C===void 0)["ArrowDown","ArrowUp","ArrowLeft","ArrowRight"].includes(K)&&ce(l,y,0,F);else{const w=a.value,v=w.findIndex(p=>p.key===C);if(v===-1)return;switch(K){case"Enter":case"NumpadEnter":r(C);break;case"ArrowDown":ce(l,w,v+1,F);break;case"ArrowUp":ce(l,w,v-1,0,!0);break;case"ArrowLeft":{const{rawNode:p,key:m,parentKey:S}=w[v];if(p.isLeaf||!o.value.includes(m)){const f=S?n.value.get(S):void 0;f&&(l.value=f.key)}else t(m,p)}break;case"ArrowRight":{const{rawNode:p,key:m}=w[v];if(!o.value.includes(m))t(m,p);else for(let S=v+1;S<F;S++){const f=w[S];l.value=f.key;break}}break}}L(e.onKeyup,u)}}}function ce(e,n,a,o,t=!1){let l=a;for(;t?l>=o:l<o;){const r=n[l];if(r.selectDisabled)t?l--:l++;else{e.value=r.key;return}}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function en(e,n,a,o,t,l,r){const c=k(()=>{var v;return(v=e.expandIcon)!=null?v:n.expandIcon}),[g,s]=J(e,"expandedKeys",()=>[]),[h,d]=J(e,"loadedKeys",()=>[]),u=E([]),K=v=>{if(!v||v.length<=0)return;const{onExpandedChange:p}=e,m=l.value,S=new Set(g.value);v.forEach(x=>{Z(m,m.get(x)).forEach(A=>S.add(A))});const f=[...S];s(f),Q(l,f,p)};qe(r,K);const C=async(v,p)=>{var $;const{loadChildren:m}=e;if(u.value.includes(v))return;const S=a.value;if(!(($=p==null?void 0:p[S])!=null&&$.length)){if(!m||u.value.includes(v)||h.value.includes(v))return;u.value.push(v);const I=await m(p);u.value.splice(u.value.indexOf(v),1);const z=l.value,O=z.get(v);if(I!=null&&I.length){const G=O.level,M=Ce(e,I,S,o.value,t.value,v,G);de(M,z),O.rawNode[S]=I,O.children=M;const H=[...h.value,v];d(H),L(e.onLoaded,H,p)}else return}const f=g.value.indexOf(v),x=f>=0,A=[...g.value];x?A.splice(f,1):A.push(v),y(x,p,A)},y=(v,p,m)=>{const{onExpand:S,onExpandedChange:f}=e;L(S,!v,p),s(m),Q(l,m,f)},F=()=>{const v=[],p=[];l.value.forEach(m=>{m.isLeaf||(v.push(m.key),p.push(m.rawNode))}),L(e.onExpandedChange,v,p),s(v)},w=()=>{L(e.onExpandedChange,[],[]),s([])};return r.value.length&&K(r.value),{expandIcon:c,expandedKeys:g,setExpandedKeys:s,expandAll:F,collapseAll:w,handleExpand:C,loadingKeys:u}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function nn(e,n,a){const o=tn(e,a);return{searchedKeys:k(()=>{const{searchValue:l}=e;if(!l)return Ie;const r=o.value,c=[];return n.value.forEach(g=>{r(g.rawNode,l)&&c.push(g.key)}),c})}}function tn(e,n){return k(()=>{var a;return(a=e.searchFn)!=null?a:an(n.value)})}function an(e){return(n,a)=>{const o=n[e];return o?o.toLowerCase().includes(a.toLowerCase()):!1}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function on(e,n){const[a,o]=J(e,"selectedKeys",()=>[]),t=k(()=>e.selectable==="multiple"),l=E();Ue(()=>{const s=a.value,h=s.length;l.value=h>0?s[h-1]:void 0});const r=k(()=>{const s=l.value;return s!==void 0?n.value.get(s):void 0}),c=s=>{const d=n.value.get(s);if(!d)return;const u=a.value.indexOf(s),K=u>-1;let C=[...a.value];t.value?K?C.splice(u,1):C.push(s):C=K?[]:[s],g(K,d.rawNode,C)},g=(s,h,d)=>{var y;const{onSelect:u,onSelectedChange:K}=e,C=d.includes((y=h.key)!=null?y:"")?!0:!s;L(u,C,h),o(d),Q(n,d,K)};return{activeKey:l,activeNode:r,selectedKeys:a,handleSelect:c}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const V=Symbol("treeToken");/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const ln={autoHeight:{type:Boolean,default:void 0},checkedKeys:Array,expandedKeys:Array,indeterminateKeys:Array,loadedKeys:Array,selectedKeys:Array,blocked:{type:Boolean,default:void 0},cascaderStrategy:{type:String,default:"off"},checkable:{type:Boolean,default:!1},childrenKey:String,checkOnClick:{type:Boolean,default:!1},customAdditional:{type:Function,default:void 0},dataSource:{type:Array,default:()=>[]},disabled:Function,draggable:{type:Boolean,default:!1},draggableIcon:{type:String,default:void 0},droppable:Function,empty:[String,Object],expandIcon:{type:[String,Array],default:void 0},getKey:{type:[String,Function],default:void 0},height:Number,labelKey:String,leafLineIcon:String,loadChildren:Function,searchFn:Function,searchValue:String,selectable:{type:[Boolean,String],default:!0},showLine:{type:Boolean,default:void 0},virtual:{type:Boolean,default:!1},"onUpdate:checkedKeys":[Function,Array],"onUpdate:expandedKeys":[Function,Array],"onUpdate:loadedKeys":[Function,Array],"onUpdate:selectedKeys":[Function,Array],onCheck:[Function,Array],onCheckedChange:[Function,Array],onDragstart:[Function,Array],onDragend:[Function,Array],onDragenter:[Function,Array],onDragleave:[Function,Array],onDragover:[Function,Array],onDrop:[Function,Array],onExpand:[Function,Array],onExpandedChange:[Function,Array],onLoaded:[Function,Array],onSelect:[Function,Array],onSelectedChange:[Function,Array],onFocus:[Function,Array],onBlur:[Function,Array],onKeydown:[Function,Array],onKeyup:[Function,Array],onNodeClick:[Function,Array],onNodeContextmenu:[Function,Array],onScroll:[Function,Array],onScrolledChange:[Function,Array],onScrolledBottom:[Function,Array]},rn={node:{type:Object,required:!0},isLeaf:{type:Boolean,required:!0},isFirst:{type:Boolean,required:!0},isLast:{type:Boolean,required:!0},label:String,level:{type:Number,required:!0},rawNode:{type:Object,required:!0},expanded:{type:Boolean,required:!0},children:Array,parentKey:[String,Number,Symbol],checkDisabled:{type:Boolean,default:void 0},dragDisabled:{type:Boolean,default:void 0},dropDisabled:{type:Boolean,default:void 0},selectDisabled:{type:Boolean,default:void 0}},cn={node:{type:Object,required:!0},checkDisabled:{type:Boolean,default:void 0}},sn={expanded:{type:Boolean,required:!0},hasTopLine:{type:Boolean,default:void 0},isLeaf:{type:Boolean,default:void 0},nodeKey:{type:[String,Number,Symbol],required:!0},rawNode:{type:Object,required:!0}},dn={disabled:{type:Boolean,default:void 0},node:{type:Object,required:!0},nodeKey:{type:[String,Number,Symbol],required:!0},label:String,selected:{type:Boolean,default:void 0}},un=R({props:cn,setup(e){const{mergedPrefixCls:n,allCheckedKeys:a,indeterminateKeys:o,handleCheck:t}=W(V),l=k(()=>a.value.includes(e.node.key)),r=k(()=>o.value.includes(e.node.key)),c=()=>t(e.node);return()=>D(Ne,{class:`${n.value}-node-checkbox`,checked:l.value,disabled:e.checkDisabled,indeterminate:r.value,onChange:c},null)}}),fn=R({props:dn,setup(e){const{props:n,mergedPrefixCls:a,mergedCheckOnClick:o,slots:t,handleSelect:l,handleCheck:r,searchedKeys:c}=W(V),g=k(()=>c.value.includes(e.nodeKey)),s=d=>{e.disabled||(l(e.nodeKey),o.value&&r(e.node)),L(n.onNodeClick,d,e.node.rawNode)},h=d=>{L(n.onNodeContextmenu,d,e.node.rawNode)};return()=>{var f,x;const{nodeKey:d,label:u,node:K,selected:C}=e,{rawNode:y}=K,{prefix:F,suffix:w}=y,v={key:d,selected:C,node:y},p=((f=t.prefix)==null?void 0:f.call(t,v))||F&&D(_,{name:F},null),m=((x=t.suffix)==null?void 0:x.call(t,v))||w&&D(_,{name:w},null),S=`${a.value}-node-content`;return D("span",{class:S,onClick:s,onContextmenu:h},[p&&D("span",{class:`${S}-prefix`},[p]),D("span",{class:`${S}-label`},[hn(t.label,u,y,n.searchValue,g.value,S)]),m&&D("span",{class:`${S}-suffix`},[m])])}}});function hn(e,n,a,o,t,l){if(e)return e({node:a,searchValue:o,searched:t});if(t&&n&&o){const r=n.toUpperCase().indexOf(o.toUpperCase());if(r>-1){const c=r+o.length,g=n.substring(0,r),s=n.substring(c),h=D("span",{class:`${l}-label-highlight`},[n.substring(r,c)]);return[g,h,s]}}return n}const vn=R({props:sn,setup(e){const{mergedPrefixCls:n,slots:a,expandIcon:o,loadingKeys:t,handleExpand:l}=W(V),r=k(()=>t.value.includes(e.nodeKey)),c=k(()=>{const s=`${n.value}-node-expand`;return ze({[s]:!0,[`${s}-noop`]:e.isLeaf})}),g=s=>{l(e.nodeKey,e.rawNode),s.stopPropagation()};return()=>{const s=`${n.value}-node-expand`;let h;if(r.value)h=D(_,{name:"loading"},null);else if(!e.isLeaf){const{expanded:d}=e;if(a.expandIcon){const{nodeKey:u,rawNode:K}=e;h=a.expandIcon({key:u,expanded:d,node:K})}else{const u=o.value,K=je(u);h=D(_,{name:K?d?u[0]:u[1]:u,rotate:d&&!K?90:0},null)}}return D("span",{class:c.value,onClick:g},[e.hasTopLine&&D("div",{class:`${s}-top-line`},null),h])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const gn=({level:e,noopIdentUnitArr:n,prefixCls:a})=>{const o=[];for(let t=0;t<e;t++)o.push(D("span",{key:t,class:n.includes(t)?`${a}-node-indent-noop-unit`:`${a}-node-indent-unit`},null));return D("span",{"aria-hidden":!0,class:`${a}-node-indent`},[o])},yn=R({setup(){const{props:e,mergedPrefixCls:n,slots:a}=W(V);return()=>{const o=`${n.value}-node-leaf`;let t;return a.leafLineIcon?t=a.leafLineIcon():e.leafLineIcon?t=D(_,{name:e.leafLineIcon},null):t=D("span",{class:`${o}-line`},null),D("span",{class:o},[t])}}}),be=R({props:rn,setup(e){const{props:n,flattedNodes:a,mergedPrefixCls:o,mergedShowLine:t,activeKey:l,selectedKeys:r,slots:c,draggableIcon:g,dragKey:s,dropKey:h,dropParentKey:d,dropType:u,handleDragstart:K,handleDragend:C,handleDragenter:y,handleDragover:F,handleDragleave:w,handleDrop:v}=W(V),p=Be(),m=k(()=>l.value===p),S=k(()=>t.value&&e.isLast),f=k(()=>t.value&&!e.isLeaf&&e.level!==0&&e.isFirst),x=k(()=>r.value.includes(p)),A=k(()=>e.selectDisabled||!n.selectable),$=k(()=>s.value===p),I=k(()=>h.value===p),z=k(()=>d.value===p),O=k(()=>I.value&&u.value==="before"),G=k(()=>I.value&&u.value==="inside"),M=k(()=>I.value&&u.value==="after"),H=k(()=>{const i=`${o.value}-node`;return{[i]:!0,[`${i}-active`]:m.value,[`${i}-last`]:S.value,[`${i}-disabled`]:A.value,[`${i}-selected`]:x.value,[`${i}-expanded`]:e.expanded,[`${i}-dragging`]:$.value,[`${i}-dropping`]:I.value,[`${i}-drop-parent`]:z.value,[`${i}-drop-before`]:O.value,[`${i}-drop-inside`]:G.value,[`${i}-drop-after`]:M.value}}),ee=i=>{var N;i.stopPropagation(),K(i,e.node),(N=i.dataTransfer)==null||N.setData("text/plain","")},ne=i=>{i.stopPropagation(),C(i,e.node)},te=i=>{i.preventDefault(),i.stopPropagation(),y(i,e.node)},ae=i=>{i.preventDefault(),i.stopPropagation(),F(i,e.node)},oe=i=>{i.stopPropagation(),w(i,e.node)},b=i=>{i.stopPropagation(),v(i,e.node)};return()=>{var he,ve;const i=new Map;a.value.forEach(Y=>{i.set(Y.key,Y)});const{isLeaf:N,label:B,level:q,rawNode:U,expanded:le,checkDisabled:re,dragDisabled:j,dropDisabled:we,node:ie}=e,{checkable:Se,draggable:ue}=n,T=ue&&!j,Ae=(ve=(he=c.draggableIcon)==null?void 0:he.call(c))!=null?ve:D(_,{name:g.value},null),Fe=i.get(p),fe=[];t.value&&Z(i,Fe).reverse().forEach((Y,$e)=>{var ge;(ge=i.get(Y))!=null&&ge.isLast&&fe.push($e)});const Le=n.customAdditional?n.customAdditional({node:U,level:q}):void 0;return D("div",se({class:H.value,"aria-grabbed":$.value||void 0,"aria-label":B,"aria-selected":x.value,draggable:T||void 0,title:B,onDragstart:T?ee:void 0,onDragend:T?ne:void 0,onDragenter:T?te:void 0,onDragover:T?ae:void 0,onDragleave:T?oe:void 0,onDrop:T&&!we?b:void 0},Le),[D(gn,{level:q,noopIdentUnitArr:fe,prefixCls:o.value},null),T?D("span",{class:`${o.value}-node-draggable-icon`},[Ae]):ue&&D("span",{class:`${o.value}-node-draggable-icon-noop`},null),N&&t.value?D(yn,null,null):D(vn,{expanded:le,hasTopLine:f.value,isLeaf:N,nodeKey:p,rawNode:U},null),Se&&D(un,{checkDisabled:re,node:ie},null),D(fn,{disabled:A.value,node:ie,nodeKey:p,label:B,selected:x.value},null)])}}}),xe={width:0,height:0,display:"flex",overflow:"hidden",opacity:0,border:0,padding:0,margin:0},pn=R({name:"IxTree",props:ln,setup(e,{attrs:n,expose:a,slots:o}){const t=ye("common"),l=k(()=>`${t.prefixCls}-tree`),r=ye("tree"),c=k(()=>{var b;return(b=e.autoHeight)!=null?b:r.autoHeight}),g=k(()=>{var b;return(b=e.childrenKey)!=null?b:r.childrenKey}),s=Ee(e,r),h=k(()=>{var b;return(b=e.labelKey)!=null?b:r.labelKey}),d=k(()=>{var b;return(b=e.showLine)!=null?b:r.showLine}),u=k(()=>{var b;return(b=e.blocked)!=null?b:r.blocked}),K=k(()=>e.checkable&&e.checkOnClick),{mergedNodes:C,mergedNodeMap:y}=Ve(e,g,s,h),{searchedKeys:F}=nn(e,y,h),w=en(e,r,g,s,h,y,F),v=Ge(C,w,e,F),p=He(e,y),m=Je(e,r,w),S=on(e,y);Me(V,{props:e,slots:o,config:r,flattedNodes:v,mergedPrefixCls:l,mergedNodeMap:y,mergedGetKey:s,mergedShowLine:d,mergedCheckOnClick:K,searchedKeys:F,...p,...w,...m,...S});const f=E(),x=E(),{activeKey:A}=S,{focused:$,handleFocus:I,handleBlur:z,handleKeydown:O,handleKeyup:G}=Ze(e,y,v,w,S),M=k(()=>{const b=l.value;return{[b]:!0,[`${b}-active`]:!P(A.value),[`${b}-blocked`]:u.value,[`${b}-virtual`]:e.virtual,[`${b}-auto-height`]:c.value,[`${b}-focused`]:$.value,[`${b}-show-line`]:d.value}}),H=k(()=>{var q,U;const b=A.value;if(P(b))return"";const i=y.value;let N=String(b),B=(q=i.get(b))==null?void 0:q.parentKey;for(;B;)N=`${String(B)} > ${N}`,B=(U=i.get(B))==null?void 0:U.parentKey;return N}),ee=b=>{var i;(i=f==null?void 0:f.value)==null||i.focus(b)},ne=()=>{var b;(b=f==null?void 0:f.value)==null||b.blur()},te=b=>{var i;(i=x.value)==null||i.scrollTo(b)},ae=b=>{var i;return(i=y.value.get(b))==null?void 0:i.rawNode};a({focus:ee,blur:ne,expandAll:w.expandAll,collapseAll:w.collapseAll,scrollTo:te,getNode:ae});const oe=(b,i,N)=>{L(e.onScrolledChange,b,i,N.map(B=>B.rawNode))};return()=>{var N;const b=v.value;let i;if(b.length>0){const B=({item:j})=>D(be,se({node:j},j),null),{height:q,virtual:U,onScroll:le,onScrolledBottom:re}=e;i=U?D(Pe,{ref:x,class:`${l.value}-content`,dataSource:b,getKey:"key",height:c.value?"100%":q,itemHeight:28,itemRender:B,virtual:!0,onScroll:le,onScrolledBottom:re,onScrolledChange:oe},null):D("div",{class:`${l.value}-content`},[D("div",{class:`${l.value}-content-inner`},[b.map(j=>D(be,se({node:j},j),null))])])}else i=D(Te,{empty:e.empty},o);return D("div",{class:M.value,role:"tree"},[$.value&&D("span",{style:xe,"aria-live":"assertive"},[H.value]),D("input",{ref:f,style:xe,tabindex:(N=n.tabIndex)!=null?N:0,onFocus:I,onBlur:z,onKeydown:O,onKeyup:G,value:"","aria-label":"for screen reader"},null),i])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const kn=pn;export{kn as I};

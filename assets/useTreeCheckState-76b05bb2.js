import{d as j,S as B,c as T,b as q}from"./vendor-4501f550.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function R(g,n,o,f="pre"){const a=(c,r)=>{for(let h=0;h<c.length;h++){const v=c[h];f==="pre"&&o(v,r),v[n]&&a(v[n],[v,...r]),f==="post"&&o(v,r)}};a(g,[])}function H(g,n,o){const f=(a,c)=>{const r=[];for(let h=0;h<a.length;h++){const v=a[h],w=o(v,c,h);if(w){if(v[n]){const M=f(v[n],[v,...c]);w[n]=M}r.push(w)}}return r};return f(g,[])}function J(g,n,o,f="or"){const a=(c,r)=>{var v;const h=[];for(let w=0;w<c.length;w++){let M;const S=c[w];S[n]&&(M=a(S[n],[S,...r]));let E=o(S,r,M);const _=M&&M.length>0||!((v=S[n])!=null&&v.length)&&E;E=f==="and"?_&&E:_||E,E&&h.push({...S,[n]:S[n]&&M})}return h};return a(g,[])}function D(g,n,o,f){var c;const a=g.map(r=>({...r}));for(const r of n){const h=a.find(v=>{const w=f(r),M=f(v);return!j(w)&&!j(M)&&w===M});if(!h){a.push({...r});continue}for(const v of[...Object.getOwnPropertyNames(r),...Object.getOwnPropertySymbols(r)])v!==o&&(h[v]=r[v]);B(r[o])&&(h[o]=D((c=h[o])!=null?c:[],r[o],o,f))}return a}function L(g,n,o,f=!1){const a=[];return R(g,n,c=>{if(!f||!c[n]||c[n].length<=0){const r=o?o(c):c;r&&a.push(r)}}),a}function N(g,n,o,f=!1){const a=[];return R(g,n,c=>{var r;(!f||!((r=c[n])!=null&&r.length))&&a.push(o(c))}),a}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function x(g,n,o,f){const a=e=>{if(!B(e))return e;const t=new Map,s=new Map,u=new Map;return R(e,n.value,(i,m)=>{const p=o.value(i),l=m[0];t.set(p,i),u.set(p,m.length),l&&s.set(p,o.value(l))}),{data:e,dataMap:t,parentKeyMap:s,depthMap:u}},c=T(()=>{var e;return(e=f==null?void 0:f.value)!=null?e:"all"}),r=T(()=>a(g.value)),h=(e,t)=>{const{parentKeyMap:s,dataMap:u}=t,i=[];let m=e;for(;s.has(m);){const p=s.get(m),l=u.get(p);l&&i.push(l),m=p}return i},v=()=>{const{data:e,parentKeyMap:t,dataMap:s}=r.value;if(e)return e;const u=[];for(const i of t.keys())!t.has(i)&&s.has(i)&&u.push(s.get(i));return u},w=(e,t,s)=>{if(!t.length)return Array.from(e);if(c.value==="off")return Array.from(new Set([...e,...t]));const{dataMap:u}=s,i=new Set(e);return t.forEach(m=>{if(!u.has(m))return;const p=u.get(m);N([p],n.value,o.value,c.value==="child").forEach(l=>{i.add(l)})}),c.value==="child"?Array.from(i).filter(m=>{var p,l;return!((l=(p=u.get(m))==null?void 0:p[n.value])!=null&&l.length)}):(t.forEach(m=>{h(m,s).forEach(p=>{var l;(l=p[n.value])!=null&&l.every(I=>i.has(o.value(I)))&&i.add(o.value(p))})}),c.value==="all"||i.forEach(m=>{var l;if(!i.has(m))return;const p=(l=u.get(m))==null?void 0:l[n.value];p&&R(p,n.value,I=>{i.delete(o.value(I))})}),Array.from(i))},M=(e,t,s)=>{if(!t.length)return Array.from(e);const u=new Set(e);if(c.value==="off")return t.forEach(l=>{u.delete(l)}),Array.from(u);const{dataMap:i}=s,m=new Set,p=l=>{m.add(l),u.delete(l)};return t.forEach(l=>{if(!i.has(l))return;N([i.get(l)],n.value,o.value).forEach(P=>{p(P)});const I=h(l,s);if(c.value==="parent"){const V=[l,...I.map(o.value)].findIndex(b=>u.has(b));V>-1&&I.slice(0,V).forEach(b=>{b[n.value]&&(b[n.value].forEach(C=>{const z=o.value(C);m.has(z)||u.add(z)}),p(o.value(b)))})}else I.forEach(P=>{p(o.value(P))})}),Array.from(u)},S=(e,t)=>w(e,t,r.value),E=(e,t)=>M(e,t,r.value),_=(e,t)=>{const s=e!=null?e:v(),u=c.value==="parent"?s.map(o.value):new Set(N(s,n.value,o.value,c.value==="child"));return M(u,t,e?a(e):r.value)},O=(e,t)=>w([],t,e?a(e):r.value);return{appendKeys:S,removeKeys:E,getAllCheckedKeys:(e,t)=>{const s=(u=>q(u==null?void 0:u[0]))(e);return _(s?e:void 0,t!=null?t:s?[]:e!=null?e:[])},getAllUncheckedKeys:(e,t)=>{const s=(u=>q(u==null?void 0:u[0]))(e);return O(s?e:void 0,t!=null?t:s?[]:e!=null?e:[])}}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Q(g,n,o,f,a,c){const r=x(n,o,f,a),h=x(n,o,f,T(()=>"all")),v=T(()=>{const{dataMap:A}=n.value,k=new Set;return A.forEach((e,t)=>{var s;(s=c.value)!=null&&s.call(c,e)&&k.add(t)}),k}),w=T(()=>{const A=a.value==="off"?g.value:h.appendKeys([],g.value);return new Set(A)}),M=T(()=>{const{parentKeyMap:A}=n.value,k=w.value;if(k.size===0||a.value==="off")return new Set;const e=new Set;return k.forEach(t=>{let s=A.get(t);if(!j(s)&&!k.has(s))for(;!j(s);)e.add(s),s=A.get(s)}),e}),S=A=>v.value.has(A),E=A=>w.value.has(A),_=A=>M.value.has(A);return{allCheckedKeySet:w,checkDisabledKeySet:v,checkStateResolver:r,isChecked:E,isCheckDisabled:S,isIndeterminate:_,toggle:A=>{var p;const k=f.value(A);if(S(k))return{checked:E(k),checkedKeys:g.value};const e=a.value!=="off"?(p=A[o.value])!=null?p:[]:[],t=E(k)||!!e.length&&e.every(l=>{const I=f.value(l);return E(I)||_(I)||S(I)}),s=r.appendKeys([],g.value),u=r[t?"removeKeys":"appendKeys"](s,[k]),i=t?[...w.value].filter(l=>S(l)):(a.value==="parent"?h.appendKeys([],u):u).filter(l=>S(l)&&!w.value.has(l)),m=r[t?"appendKeys":"removeKeys"](u,i);return{checked:!t,checkedKeys:m}}}}export{x as a,D as b,L as c,J as f,N as g,H as m,R as t,Q as u};

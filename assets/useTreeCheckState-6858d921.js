import{b0 as H,b5 as b,b6 as j,q as Q}from"./index-b2ce1350.js";import{c as T,k as J,b as q,d as z,s as B,w as F,ah as N}from"./vendor-489a52b6.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function G(S,p,c,f){const M=e=>J(e)?L(e,p.value,c.value):e,h=T(()=>{var e;return(e=f==null?void 0:f.value)!=null?e:"all"}),w=T(()=>M(S.value)),A=(e,o)=>{const{parentKeyMap:r,dataMap:l}=o,u=[];let g=e;for(;r.has(g);){const a=r.get(g),t=l.get(a);t&&u.push(t),g=a}return u},d=()=>{const{data:e,parentKeyMap:o,dataMap:r}=w.value;if(e)return e;const l=[];for(const u of o.keys())!o.has(u)&&r.has(u)&&l.push(r.get(u));return l},_=(e,o,r)=>{if(!o.length)return Array.from(e);if(h.value==="off")return Array.from(new Set([...e,...o]));const{dataMap:l}=r,u=new Set(e),g=new Set;return o.forEach(a=>{if(!l.has(a)||u.has(a))return;const n=l.get(a)[p.value];u.add(a),g.add(a),n!=null&&n.length&&b(n,p.value,c.value,h.value==="child").forEach(s=>{u.add(s),g.delete(s)})}),h.value==="child"?Array.from(u).filter(a=>{var t,n;return!((n=(t=l.get(a))==null?void 0:t[p.value])!=null&&n.length)}):(g.forEach(a=>{A(a,r).forEach(t=>{var n;(n=t[p.value])!=null&&n.every(s=>u.has(c.value(s)))&&u.add(c.value(t))})}),h.value==="all"||u.forEach(a=>{var n;if(!u.has(a))return;const t=(n=l.get(a))==null?void 0:n[p.value];t&&H(t,p.value,s=>{u.delete(c.value(s))})}),Array.from(u))},E=(e,o,r)=>{if(!o.length)return Array.from(e);const l=new Set(e);if(h.value==="off")return o.forEach(t=>{l.delete(t)}),Array.from(l);const{dataMap:u}=r,g=new Set,a=t=>{g.add(t),l.delete(t)};return o.forEach(t=>{if(!u.has(t))return;b([u.get(t)],p.value,c.value).forEach(s=>{a(s)});const n=A(t,r);if(h.value==="parent"){const v=[t,...n.map(c.value)].findIndex(i=>l.has(i));v>-1&&n.slice(0,v).forEach(i=>{i[p.value]&&(i[p.value].forEach(k=>{const y=c.value(k);g.has(y)||l.add(y)}),a(c.value(i)))})}else n.forEach(s=>{a(c.value(s))})}),Array.from(l)},K=(e,o)=>_(e,o,w.value),P=(e,o)=>E(e,o,w.value),I=(e,o)=>{const r=e!=null?e:d(),l=h.value==="parent"?r.map(c.value):new Set(b(r,p.value,c.value,h.value==="child"));return E(l,o,e?M(e):w.value)},D=(e,o)=>_([],o,e?M(e):w.value);return{appendKeys:K,removeKeys:P,getAllCheckedKeys:(e,o)=>{const r=(l=>q(l==null?void 0:l[0]))(e);return I(r?e:void 0,o!=null?o:r?[]:e!=null?e:[])},getAllUncheckedKeys:(e,o)=>{const r=(l=>q(l==null?void 0:l[0]))(e);return D(r?e:void 0,o!=null?o:r?[]:e!=null?e:[])}}}function L(S,p,c){const f=new Map,M=new Map,h=new Map;return H(S,p,(w,A)=>{const d=c(w),_=A[0];f.set(d,w),h.set(d,A.length),_&&M.set(d,c(_))}),{data:S,dataMap:f,parentKeyMap:M,depthMap:h}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Y(S,p,c,f,M,h){const{mergedResolverContext:w,cachedSelectedData:A,checkStateResolver:d,allCheckStateResolver:_,allCheckedKeySet:E,unexistedKeys:K}=V(S,p,c,f,M),P=T(()=>{const{dataMap:a}=w.value,t=new Set;return a.forEach((n,s)=>{var v;(v=h.value)!=null&&v.call(h,n)&&t.add(s)}),t}),I=T(()=>{const{parentKeyMap:a}=w.value,t=E.value;if(t.size===0||M.value==="off")return new Set;const n=new Set;return t.forEach(s=>{let v=a.get(s);if(!z(v)&&!t.has(v))for(;!z(v);)n.add(v),v=a.get(v)}),n}),D=a=>P.value.has(a),m=a=>E.value.has(a),C=a=>I.value.has(a),e=a=>K.value?[...a,...K.value]:a,o=a=>{var R;const t=f.value(a);if(D(t))return{checked:m(t),checkedKeys:S.value};const n=M.value!=="off"?(R=a[c.value])!=null?R:[]:[],s=m(t)||!!n.length&&n.every(x=>{const U=f.value(x);return m(U)||C(U)||D(U)}),v=d.appendKeys([],S.value),i=d[s?"removeKeys":"appendKeys"](v,[t]),k=s?[...E.value].filter(x=>D(x)):(M.value==="parent"?_.appendKeys([],i):i).filter(x=>D(x)&&!E.value.has(x)),y=e(d[s?"appendKeys":"removeKeys"](i,k));return{checked:!s,checkedKeys:y}},r=(a,t,n)=>{var y;const s=(R=>J(R)&&q(R==null?void 0:R[0]))(a),v=(y=s?N(t)?[]:t:a)!=null?y:[],i=s?N(t)?t:n:void 0,k=s?i?j(a,A.value,c.value,f.value):a:[];return{dataProvided:s,data:k,defaultKeys:v,cached:i}};return{allCheckedKeySet:E,checkDisabledKeySet:P,checkStateResolver:d,isChecked:m,isCheckDisabled:D,isIndeterminate:C,toggle:o,getAllCheckedKeys:(a,t,n)=>{const s=r(a,t,n),v=s.dataProvided?d.getAllCheckedKeys(s.data,s.defaultKeys):d.getAllCheckedKeys(s.defaultKeys);return e(v)},getAllUncheckedKeys:(a,t,n)=>{const s=r(a,t,n),v=s.dataProvided?d.getAllUncheckedKeys(s.data,s.defaultKeys):d.getAllUncheckedKeys(s.defaultKeys);return e(v)},getDataByKeys:a=>{const{dataMap:t}=w.value;return a.map(n=>t.get(n)).filter(Boolean)}}}function V(S,p,c,f,M){const h=B([]),w=T(()=>L(h.value,c.value,f.value)),A=B(p.value),d=B(new Set),_={value:[]},E=G(A,c,f,M),K=G(A,c,f,T(()=>"all")),P=()=>{I();const{data:m,dataMap:C,parentKeyMap:e,depthMap:o}=p.value,{data:r,dataMap:l,parentKeyMap:u,depthMap:g}=w.value,a=j(m!=null?m:[],r!=null?r:[],c.value,f.value),t=new Map(C),n=new Map(l);t.forEach((i,k)=>{if(n.has(k)){const y=n.get(k);t.set(k,j([i],[y],c.value,f.value)[0]),n.delete(k)}}),n.forEach((i,k)=>{t.set(k,i)});const s=new Map([...u,...e]),v=new Map([...g,...o]);A.value={data:a,dataMap:t,parentKeyMap:s,depthMap:v}},I=()=>{const{data:m}=A.value,C=d.value;h.value=Q(m!=null?m:[],c.value,e=>C.has(f.value(e)),"or")},D=()=>{const m=M.value==="off"?S.value:K.appendKeys([],S.value),C=new Set(m);d.value=C;const e=S.value.filter(o=>!C.has(o));_.value=e};return F(p,P),F([S,A,M],D,{immediate:!0}),{mergedResolverContext:A,cachedSelectedData:h,checkStateResolver:E,allCheckStateResolver:K,allCheckedKeySet:d,unexistedKeys:_}}export{G as a,Y as u};

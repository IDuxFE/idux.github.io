import{m as B,ao as ae,A as V,at as Te,j as Pe,M as Ce,N as Oe,aw as _e,H as He,aK as qe,av as je}from"./index-c8d09f7e.js";import{d as j,U as me,c as x,b as we,r as O,w as Ne,n as Re,f as ze,x as Ke,i as Ue,N as Ve,l as W,y as Y,q as L,p as We,a8 as be,D as Ge,Q as Qe}from"./vendor-754a3ca4.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function oe(e,n,t,r="pre"){const o=(a,l)=>{for(let s=0;s<a.length;s++){const v=a[s];r==="pre"&&t(v,l),v[n]&&o(v[n],[v,...l]),r==="post"&&t(v,l)}};o(e,[])}function In(e,n,t){const r=(o,a)=>{const l=[];for(let s=0;s<o.length;s++){const v=o[s],f=t(v,a,s);if(f){if(v[n]){const b=r(v[n],[v,...a]);f[n]=b}l.push(f)}}return l};return r(e,[])}function Nn(e,n,t,r="or"){const o=(a,l)=>{var v;const s=[];for(let f=0;f<a.length;f++){let b;const m=a[f];m[n]&&(b=o(m[n],[m,...l]));let k=t(m,l,b);const w=b&&b.length>0||!((v=m[n])!=null&&v.length)&&k;k=r==="and"?w&&k:w||k,k&&s.push({...m,[n]:m[n]&&b})}return s};return o(e,[])}function Xe(e,n,t,r){var a;const o=e.map(l=>({...l}));for(const l of n){const s=o.find(v=>{const f=r(l),b=r(v);return!j(f)&&!j(b)&&f===b});if(!s){o.push({...l});continue}for(const v of[...Object.getOwnPropertyNames(l),...Object.getOwnPropertySymbols(l)])v!==t&&(s[v]=l[v]);me(l[t])&&(s[t]=Xe((a=s[t])!=null?a:[],l[t],t,r))}return o}function Fn(e,n,t,r=!1){const o=[];return oe(e,n,a=>{if(!r||!a[n]||a[n].length<=0){const l=t?t(a):a;l&&o.push(l)}}),o}function pe(e,n,t,r=!1){const o=[];return oe(e,n,a=>{var l;(!r||!((l=a[n])!=null&&l.length))&&o.push(t(a))}),o}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Se(e,n,t,r){const o=h=>{if(!me(h))return h;const c=new Map,g=new Map,y=new Map;return oe(h,n.value,(i,d)=>{const u=t.value(i),p=d[0];c.set(u,i),y.set(u,d.length),p&&g.set(u,t.value(p))}),{data:h,dataMap:c,parentKeyMap:g,depthMap:y}},a=x(()=>{var h;return(h=r==null?void 0:r.value)!=null?h:"all"}),l=x(()=>o(e.value)),s=(h,c)=>{const{parentKeyMap:g,dataMap:y}=c,i=[];let d=h;for(;g.has(d);){const u=g.get(d),p=y.get(u);p&&i.push(p),d=u}return i},v=()=>{const{data:h,parentKeyMap:c,dataMap:g}=l.value;if(h)return h;const y=[];for(const i of c.keys())!c.has(i)&&g.has(i)&&y.push(g.get(i));return y},f=(h,c,g)=>{if(!c.length)return Array.from(h);if(a.value==="off")return Array.from(new Set([...h,...c]));const{dataMap:y}=g,i=new Set(h);return c.forEach(d=>{if(!y.has(d))return;const u=y.get(d);pe([u],n.value,t.value,a.value==="child").forEach(p=>{i.add(p)})}),a.value==="child"?Array.from(i).filter(d=>{var u,p;return!((p=(u=y.get(d))==null?void 0:u[n.value])!=null&&p.length)}):(c.forEach(d=>{s(d,g).forEach(u=>{var p;(p=u[n.value])!=null&&p.every(S=>i.has(t.value(S)))&&i.add(t.value(u))})}),a.value==="all"||i.forEach(d=>{var p;if(!i.has(d))return;const u=(p=y.get(d))==null?void 0:p[n.value];u&&oe(u,n.value,S=>{i.delete(t.value(S))})}),Array.from(i))},b=(h,c,g)=>{if(!c.length)return Array.from(h);const y=new Set(h);if(a.value==="off")return c.forEach(p=>{y.delete(p)}),Array.from(y);const{dataMap:i}=g,d=new Set,u=p=>{d.add(p),y.delete(p)};return c.forEach(p=>{if(!i.has(p))return;pe([i.get(p)],n.value,t.value).forEach(A=>{u(A)});const S=s(p,g);if(a.value==="parent"){const E=[p,...S.map(t.value)].findIndex(T=>y.has(T));E>-1&&S.slice(0,E).forEach(T=>{T[n.value]&&(T[n.value].forEach(M=>{const $=t.value(M);d.has($)||y.add($)}),u(t.value(T)))})}else S.forEach(A=>{u(t.value(A))})}),Array.from(y)},m=(h,c)=>f(h,c,l.value),k=(h,c)=>b(h,c,l.value),w=(h,c)=>{const g=h!=null?h:v(),y=a.value==="parent"?g.map(t.value):new Set(pe(g,n.value,t.value,a.value==="child"));return b(y,c,h?o(h):l.value)},K=(h,c)=>f([],c,h?o(h):l.value);return{appendKeys:m,removeKeys:k,getAllCheckedKeys:(h,c)=>{const g=(y=>we(y==null?void 0:y[0]))(h);return w(g?h:void 0,c!=null?c:g?[]:h!=null?h:[])},getAllUncheckedKeys:(h,c)=>{const g=(y=>we(y==null?void 0:y[0]))(h);return K(g?h:void 0,c!=null?c:g?[]:h!=null?h:[])}}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function X(e,n,t){if(t){const r=[],o=e.value;n.forEach(a=>{const l=o.get(a);l&&r.push(l.rawNode)}),B(t,n,r)}}function Fe(e,n){const t=[],{children:r}=e||{};return r&&r.forEach(o=>{const{key:a}=o;n!=null&&n.includes(a)||t.push(o.key),t.push(...Fe(o,n))}),t}function Me(e,n,t){const r=[];for(;n&&!j(n.parentKey);){const{parentKey:o}=n;t!=null&&t.includes(n.parentKey)||r.push(o),n=e.get(o)}return r}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Ye(e,n,t,r,o){const[a,l]=ae(e,"checkedKeys",()=>[]),s=x(()=>({data:n.value,dataMap:t.value,parentKeyMap:r.value,depthMap:o.value})),v=O("children"),f=O(i=>i.key),b=x(()=>e.cascaderStrategy),m=Se(s,v,f,b),k=Se(s,v,f,x(()=>b.value==="off"?"off":"all")),w=x(()=>{const i=new Set;return e.checkable&&t.value.forEach((d,u)=>{d.checkDisabled&&i.add(u)}),i}),K=x(()=>{const i=k.appendKeys([],a.value);return new Set(i)}),I=x(()=>{const i=K.value;if(i.size===0||e.cascaderStrategy==="off")return new Set;const d=new Set,u=t.value;return i.forEach(p=>{const{parentKey:S}=u.get(p)||{};if(!j(S)){let A=u.get(S);if(A&&!i.has(A.key))for(d.add(S);A&&!j(A.parentKey);)d.add(A.parentKey),A=u.get(A.parentKey)}}),d}),F=i=>w.value.has(i),h=i=>K.value.has(i),c=i=>I.value.has(i),g=i=>{var M;const d=i.key;if(i.checkDisabled)return;const u=b.value!=="off"?(M=i.children)!=null?M:[]:[],p=h(d)||!!u.length&&u.every($=>h($.key)||c($.key)||F($.key)),S=m.appendKeys([],a.value),A=m[p?"removeKeys":"appendKeys"](S,[d]),E=p?[...K.value].filter($=>F($)):(b.value==="parent"?k.appendKeys([],A):A).filter($=>F($)&&!K.value.has($)),T=m[p?"appendKeys":"removeKeys"](A,E);y(p,i.rawNode,T)},y=(i,d,u)=>{const{onCheck:p,onCheckedChange:S}=e;B(p,!i,d),l(u),X(t,u,S)};return Ne(b,()=>{const i=m.appendKeys([],a.value);l(i),X(t,i,e.onCheckedChange)}),{checkedKeys:a,isChecked:h,isIndeterminate:c,handleCheck:g}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Je(e,n,t,r){const o=O({}),a=(k,w)=>{o.value[k]=w},l=k=>o.value[k],s=x(()=>{const k=new Map,w=new Map,K=new Map;return{mergedNodes:Be(e.dataSource,l,{props:e,childrenKey:n.value,getKey:t.value,labelKey:r.value,parentKey:void 0,parentLevel:-1,parentsDisabled:[]},{dataKeyMap:k,parentKeyMap:w,depthMap:K}),dataKeyMap:k,parentKeyMap:w,depthMap:K}}),v=x(()=>s.value.mergedNodes),f=x(()=>s.value.dataKeyMap),b=x(()=>s.value.parentKeyMap),m=x(()=>s.value.depthMap);return{mergedNodes:v,mergedNodeMap:f,parentKeyMap:b,depthMap:m,setLoadedNodes:a}}function Ze(e,{expandedKeys:n},t,r){return x(()=>{const{searchValue:o}=t,a=new Map(n.value.map((s,v)=>[s,v])),l=new Map(r.value.map((s,v)=>[s,v]));return o&&!l.size?[]:a.size||l.size?tn(e.value,a,l):e.value.map(s=>({...s,expanded:!1,level:0}))})}function Be(e,n,t,r){const{props:o,childrenKey:a,getKey:l,labelKey:s,parentKey:v,parentLevel:f,parentsDisabled:b}=t,{cascaderStrategy:m,disabled:k,loadChildren:w}=o,{dataKeyMap:K,parentKeyMap:I,depthMap:F}=r,h=!!w;return e.map((c,g)=>{var T,M,$;const y=l(c),i=en(c,k),d=(T=c[a])!=null?T:n(y),u=c[s],p=f+1,S=d&&Be(d,n,{props:o,childrenKey:a,getKey:l,labelKey:s,parentKey:y,parentLevel:p,parentsDisabled:[i,...b!=null?b:[]]},r),A=nn(i,b!=null?b:[],(M=S==null?void 0:S.map(q=>({check:q.checkDisabled,drag:q.dragDisabled,drop:q.dropDisabled,select:q.selectDisabled})))!=null?M:[],m!=="off"),E={label:u,key:y,children:S,isFirst:g===0,isLeaf:($=c.isLeaf)!=null?$:!(d!=null&&d.length||h),isLast:g===e.length-1,parentKey:v,expanded:!1,level:p,rawNode:c,checkDisabled:A.check,dragDisabled:A.drag,dropDisabled:A.drop,selectDisabled:A.select};return K.set(y,E),I.set(y,v),F.set(y,p),E})}function en(e,n){const t=e.disabled||{};if(t===!0)return{check:!0,drag:!0,drop:!0,select:!0};let{check:r,drag:o,drop:a,select:l}=t;if(n){const s=n(e)||{};if(s===!0)return{check:!0,drag:!0,drop:!0,select:!0};r=r||s.check,o=o||s.drag,a=a||s.drop,l=l||s.select}return{check:r,drag:o,drop:a,select:l}}function nn(e,n,t,r){const o=a=>e[a]||r&&(n.some(l=>!!l[a])||!!t.length&&t.every(l=>!!l[a]));return{check:o("check"),drag:o("drag"),drop:o("drop"),select:o("select")}}function $e(e=[],n){const t=[],r=e.length;return e.forEach((o,a)=>{o.isFirst=a===0,o.isLast=a===r-1,n.has(o.key)||n.size==0?(o.hidden=!1,t.push(o)):o.hidden=!0,$e(o.children,n).length>0&&(o.hidden=!1,t.push(o))}),t.length&&(t[0].isFirst=!0,t[t.length-1].isLast=!0),t}function tn(e,n,t){const r=[],o=[];return $e(e,t),e.forEach(a=>{for(o.push(a);o.length;){const l=o.pop();if(l){const{children:s,key:v,hidden:f}=l,b=n.has(v);if(l.expanded=b,!f&&r.push(l),s&&b)for(let m=s.length;m>0;m--)!s[m-1].hidden&&o.push(s[m-1])}}}),r}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function an(e,n,{expandedKeys:t,setExpandedKeys:r}){const o=x(()=>{var d;return(d=e.draggableIcon)!=null?d:n.draggableIcon}),a=O(),l=O(),s=O(),v=O(),f=O();let b;const m=()=>{b&&(clearTimeout(b),b=void 0)};Re(()=>m());const k=()=>{j(a.value)||(a.value=void 0,l.value=void 0)},w=()=>{j(s.value)||(s.value=void 0,v.value=void 0,f.value=void 0)},K=(d,u)=>{var p,S;return{evt:d,node:u.rawNode,dragNode:(p=a.value)==null?void 0:p.rawNode,dropNode:(S=s.value)==null?void 0:S.rawNode,dropType:f.value}},I=d=>{h(d,void 0),window.removeEventListener("dragend",I)},F=(d,u)=>{a.value=u,l.value=Fe(u),rn(u.key,t.value,r),window.addEventListener("dragend",I),B(e.onDragstart,K(d,u))},h=(d,u)=>{u&&B(e.onDragend,K(d,u)),k(),w()},c=async(d,u)=>{const p=a.value;if(p){m(),p.key!==u.key&&(b=setTimeout(()=>{var A;a.value&&((A=u.children)!=null&&A.length)&&on(u.key,t.value,r),b=void 0},1e3));const S=await De(u,p,l.value,d,e.droppable);S?(s.value=u,v.value=S!=="inside"?u.parentKey:void 0,f.value=S):w()}B(e.onDragenter,K(d,u))},g=async(d,u)=>{const p=a.value;if(p){const S=await De(u,p,l.value,d,e.droppable);S?(s.value=u,v.value=S!=="inside"?u.parentKey:void 0,f.value=S):w()}B(e.onDragover,K(d,u))},y=(d,u)=>{const p=s.value;(p==null?void 0:p.key)===u.key&&!d.currentTarget.contains(d.relatedTarget)&&w(),B(e.onDragleave,K(d,u))},i=(d,u)=>{f.value||w(),B(e.onDrop,K(d,u)),k(),w()};return{draggableIcon:o,dragKey:x(()=>{var d;return(d=a.value)==null?void 0:d.key}),dropKey:x(()=>{var d;return(d=s.value)==null?void 0:d.key}),dropParentKey:v,dropType:f,handleDragstart:F,handleDragend:h,handleDragenter:c,handleDragover:g,handleDragleave:y,handleDrop:i}}function on(e,n,t){n.indexOf(e)===-1&&t([...n,e])}function rn(e,n,t){const r=n.indexOf(e);if(r!==-1){const o=[...n];o.splice(r,1),t(o)}}async function De(e,n,t,r,o){const{key:a,children:l=[]}=e;if(n.key===a||t&&t.includes(a))return!1;const{clientY:s}=r,{top:v,height:f}=r.target.getBoundingClientRect(),b=s<v+f/2;let m;if(o){const k={evt:r,isTopHalf:b,dragNode:n.rawNode,dropNode:e.rawNode};m=await o(k)}return(m===void 0||m===!0)&&(l.length>0?m="inside":b?m="before":m="after"),m}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function ln(e,n,t,{expandedKeys:r,handleExpand:o},{activeKey:a,handleSelect:l}){const s=O(!1);return{focused:s,handleFocus:k=>{s.value=!0,B(e.onFocus,k)},handleBlur:k=>{s.value=!0,B(e.onBlur,k)},handleKeydown:k=>{switch(k.code){case"ArrowUp":case"ArrowDown":k.preventDefault()}B(e.onKeydown,k)},handleKeyup:k=>{const w=k.code,K=a.value,I=t.value,F=I.length;if(K===void 0)["ArrowDown","ArrowUp","ArrowLeft","ArrowRight"].includes(w)&&ye(a,I,0,F);else{const h=t.value,c=h.findIndex(g=>g.key===K);if(c===-1)return;switch(w){case"Enter":case"NumpadEnter":l(K);break;case"ArrowDown":ye(a,h,c+1,F);break;case"ArrowUp":ye(a,h,c-1,0,!0);break;case"ArrowLeft":{const{rawNode:g,key:y,parentKey:i}=h[c];if(g.isLeaf||!r.value.includes(y)){const d=i?n.value.get(i):void 0;d&&(a.value=d.key)}else o(y,g)}break;case"ArrowRight":{const{rawNode:g,key:y}=h[c];if(!r.value.includes(y))o(y,g);else for(let i=c+1;i<F;i++){const d=h[i];a.value=d.key;break}}break}}B(e.onKeyup,k)}}}function ye(e,n,t,r,o=!1){let a=t;for(;o?a>=r:a<r;){const l=n[a];if(l.selectDisabled)o?a--:a++;else{e.value=l.key;return}}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function cn(e,n,t,r,o,a){const l=x(()=>{var c;return(c=e.expandIcon)!=null?c:n.expandIcon}),[s,v]=ae(e,"expandedKeys",()=>[]),[f,b]=ae(e,"loadedKeys",()=>[]),m=O([]),k=({key:c,expanded:g,node:y})=>{if(ze(l.value))return Ke(V,{name:l.value,rotate:g?90:0});if(Ue(l.value))return l.value({key:c,expanded:g,node:y});if(me(l.value))return Ke(V,{name:g?l.value[0]:l.value[1]})},w=c=>{if(!c||c.length<=0)return;const{onExpandedChange:g}=e,y=r.value,i=new Set(s.value);c.forEach(u=>{Me(y,y.get(u)).forEach(p=>i.add(p))});const d=[...i];v(d),X(r,d,g)};Ne(o,w);const K=async(c,g)=>{var S;const{loadChildren:y}=e;if(m.value.includes(c))return;const i=t.value;if(!((S=g==null?void 0:g[i])!=null&&S.length)){if(!y||m.value.includes(c)||f.value.includes(c))return;m.value.push(c);const A=await y(g);m.value.splice(m.value.indexOf(c),1);const T=r.value.get(c);if(A!=null&&A.length){a(c,A),T.rawNode[i]=A;const M=[...f.value,c];b(M),B(e.onLoaded,M,g)}else return}const d=s.value.indexOf(c),u=d>=0,p=[...s.value];u?p.splice(d,1):p.push(c),I(u,g,p)},I=(c,g,y)=>{const{onExpand:i,onExpandedChange:d}=e;B(i,!c,g),v(y),X(r,y,d)},F=()=>{const c=[],g=[];r.value.forEach(y=>{y.isLeaf||(c.push(y.key),g.push(y.rawNode))}),B(e.onExpandedChange,c,g),v(c)},h=()=>{B(e.onExpandedChange,[],[]),v([])};return o.value.length&&w(o.value),{expandIconRenderer:k,expandedKeys:s,setExpandedKeys:v,expandAll:F,collapseAll:h,handleExpand:K,loadingKeys:m}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function sn(e,n,t){const r=dn(e,t);return{searchedKeys:x(()=>{const{searchValue:a}=e;if(!a)return Te;const l=r.value,s=[];return n.value.forEach(v=>{l(v.rawNode,a)&&s.push(v.key)}),s})}}function dn(e,n){return x(()=>{var t;return(t=e.searchFn)!=null?t:un(n.value)})}function un(e){return(n,t)=>{const r=n[e];return r?r.toLowerCase().includes(t.toLowerCase()):!1}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function fn(e,n){const[t,r]=ae(e,"selectedKeys",()=>[]),o=x(()=>e.selectable==="multiple"),a=O();Ve(()=>{const f=t.value,b=f.length;a.value=b>0?f[b-1]:void 0});const l=x(()=>{const f=a.value;return f!==void 0?n.value.get(f):void 0}),s=f=>{const m=n.value.get(f);if(!m)return;const k=t.value.indexOf(f),w=k>-1;let K=[...t.value];o.value?w?K.splice(k,1):K.push(f):K=w?[]:[f],v(w,m.rawNode,K)},v=(f,b,m)=>{var I;const{onSelect:k,onSelectedChange:w}=e,K=m.includes((I=b.key)!=null?I:"")?!0:!f;B(k,K,b),r(m),X(n,m,w)};return{activeKey:a,activeNode:l,selectedKeys:t,handleSelect:s}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const G=Symbol("treeToken");/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const vn={autoHeight:{type:Boolean,default:void 0},checkedKeys:Array,expandedKeys:Array,indeterminateKeys:Array,loadedKeys:Array,selectedKeys:Array,blocked:{type:Boolean,default:void 0},cascaderStrategy:{type:String,default:"off"},checkable:{type:Boolean,default:!1},childrenKey:String,checkOnClick:{type:Boolean,default:!1},customAdditional:{type:Function,default:void 0},dataSource:{type:Array,default:()=>[]},disabled:Function,draggable:{type:Boolean,default:!1},draggableIcon:{type:String,default:void 0},droppable:Function,empty:{type:[String,Object],default:"simple"},expandIcon:{type:[String,Function,Array],default:void 0},getKey:{type:[String,Function],default:void 0},height:Number,labelKey:String,leafLineIcon:String,loadChildren:Function,searchFn:Function,searchValue:String,selectable:{type:[Boolean,String],default:!0},showLine:{type:Boolean,default:void 0},virtual:{type:Boolean,default:!1},virtualScrollMode:{type:String,default:void 0},virtualItemHeight:{type:Number,default:28},"onUpdate:checkedKeys":[Function,Array],"onUpdate:expandedKeys":[Function,Array],"onUpdate:loadedKeys":[Function,Array],"onUpdate:selectedKeys":[Function,Array],onCheck:[Function,Array],onCheckedChange:[Function,Array],onDragstart:[Function,Array],onDragend:[Function,Array],onDragenter:[Function,Array],onDragleave:[Function,Array],onDragover:[Function,Array],onDrop:[Function,Array],onExpand:[Function,Array],onExpandedChange:[Function,Array],onLoaded:[Function,Array],onSelect:[Function,Array],onSelectedChange:[Function,Array],onFocus:[Function,Array],onBlur:[Function,Array],onKeydown:[Function,Array],onKeyup:[Function,Array],onNodeClick:[Function,Array],onNodeContextmenu:[Function,Array],onScroll:[Function,Array],onScrolledChange:[Function,Array],onScrolledBottom:[Function,Array]},hn={node:{type:Object,required:!0},isLeaf:{type:Boolean,required:!0},isFirst:{type:Boolean,required:!0},isLast:{type:Boolean,required:!0},label:String,level:{type:Number,required:!0},rawNode:{type:Object,required:!0},expanded:{type:Boolean,required:!0},children:Array,parentKey:[String,Number,Symbol],checkDisabled:{type:Boolean,default:void 0},dragDisabled:{type:Boolean,default:void 0},dropDisabled:{type:Boolean,default:void 0},selectDisabled:{type:Boolean,default:void 0}},gn={node:{type:Object,required:!0},checkDisabled:{type:Boolean,default:void 0}},pn={expanded:{type:Boolean,required:!0},hasTopLine:{type:Boolean,default:void 0},hasBottomLine:{type:Boolean,default:void 0},isLeaf:{type:Boolean,default:void 0},nodeKey:{type:[String,Number,Symbol],required:!0},rawNode:{type:Object,required:!0}},yn={disabled:{type:Boolean,default:void 0},node:{type:Object,required:!0},nodeKey:{type:[String,Number,Symbol],required:!0},label:String,selected:{type:Boolean,default:void 0}},bn=W({props:gn,setup(e){const{mergedPrefixCls:n,isChecked:t,isIndeterminate:r,handleCheck:o}=Y(G),a=x(()=>t(e.node.key)),l=x(()=>r(e.node.key)),s=()=>o(e.node);return()=>L(Pe,{class:`${n.value}-node-checkbox`,checked:a.value,disabled:e.checkDisabled,indeterminate:l.value,onChange:s},null)}}),mn=W({props:yn,setup(e,{slots:n}){const{props:t,mergedPrefixCls:r,mergedCheckOnClick:o,handleSelect:a,handleCheck:l,searchedKeys:s}=Y(G),v=x(()=>s.value.includes(e.nodeKey)),f=m=>{e.disabled||(a(e.nodeKey),o.value&&l(e.node)),B(t.onNodeClick,m,e.node.rawNode)},b=m=>{B(t.onNodeContextmenu,m,e.node.rawNode)};return()=>{var d,u;const{nodeKey:m,label:k,node:w,selected:K}=e,{rawNode:I}=w,{prefix:F,suffix:h}=I,c={key:m,selected:K,node:I},g=((d=n.prefix)==null?void 0:d.call(n,c))||F&&L(V,{name:F},null),y=((u=n.suffix)==null?void 0:u.call(n,c))||h&&L(V,{name:h},null),i=`${r.value}-node-content`;return L("span",{class:i,onClick:f,onContextmenu:b},[g&&L("span",{class:`${i}-prefix`},[g]),L("span",{class:`${i}-label`},[kn(n.label,k,I,t.searchValue,v.value,i)]),y&&L("span",{class:`${i}-suffix`},[y])])}}});function kn(e,n,t,r,o,a){if(e)return e({node:t,searchValue:r,searched:o});if(o&&n&&r){const l=n.toUpperCase().indexOf(r.toUpperCase());if(l>-1){const s=l+r.length,v=n.substring(0,l),f=n.substring(s),b=L("span",{class:`${a}-label-highlight`},[n.substring(l,s)]);return[v,b,f]}}return n}const xn=W({props:pn,setup(e,{slots:n}){const{mergedPrefixCls:t,expandIconRenderer:r,loadingKeys:o,handleExpand:a}=Y(G),l=x(()=>o.value.includes(e.nodeKey)),s=x(()=>{const f=`${t.value}-node-expand`;return We({[f]:!0,[`${f}-noop`]:e.isLeaf})}),v=f=>{a(e.nodeKey,e.rawNode),f.stopPropagation()};return()=>{var m,k;const f=`${t.value}-node-expand`;let b;if(l.value)b=L(V,{name:"loading"},null);else if(!e.isLeaf){const{expanded:w,nodeKey:K,rawNode:I}=e;b=(k=(m=n.expandIcon)!=null?m:r)==null?void 0:k({key:K,expanded:w,node:I})}return L("span",{class:s.value,onClick:v},[e.hasTopLine&&L("div",{class:`${f}-top-line`},null),b,e.hasBottomLine&&L("div",{class:`${f}-bottom-line`},null)])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const Cn=({level:e,noopIdentUnitArr:n,prefixCls:t})=>{const r=[];for(let o=0;o<e;o++)r.push(L("span",{key:o,class:n.includes(o)?`${t}-node-indent-noop-unit`:`${t}-node-indent-unit`},null));return L("span",{"aria-hidden":!0,class:`${t}-node-indent`},[r])},wn=Cn,Kn=W({setup(e,{slots:n}){const{props:t,mergedPrefixCls:r}=Y(G);return()=>{const o=`${r.value}-node-leaf`;let a;return n.leafLineIcon?a=n.leafLineIcon():t.leafLineIcon?a=L(V,{name:t.leafLineIcon},null):a=L("span",{class:`${o}-line`},null),L("span",{class:o},[a])}}}),Ae=W({props:hn,setup(e,{slots:n}){const{props:t,flattedNodes:r,mergedPrefixCls:o,mergedShowLine:a,activeKey:l,selectedKeys:s,draggableIcon:v,dragKey:f,dropKey:b,dropParentKey:m,dropType:k,handleDragstart:w,handleDragend:K,handleDragenter:I,handleDragover:F,handleDragleave:h,handleDrop:c}=Y(G),g=x(()=>e.node.key),y=x(()=>l.value===g.value),i=x(()=>a.value&&e.isLast),d=x(()=>a.value&&!e.isLeaf&&(!e.isFirst||e.level!==0)),u=x(()=>a.value&&!e.isLeaf&&!e.isLast),p=x(()=>s.value.includes(g.value)),S=x(()=>e.selectDisabled||!t.selectable),A=x(()=>f.value===g.value),E=x(()=>b.value===g.value),T=x(()=>m.value===g.value),M=x(()=>E.value&&k.value==="before"),$=x(()=>E.value&&k.value==="inside"),q=x(()=>E.value&&k.value==="after"),J=x(()=>{const D=`${o.value}-node`;return{[D]:!0,[`${D}-active`]:y.value,[`${D}-last`]:i.value,[`${D}-disabled`]:S.value,[`${D}-selected`]:p.value,[`${D}-expanded`]:e.expanded,[`${D}-dragging`]:A.value,[`${D}-dropping`]:E.value,[`${D}-drop-parent`]:T.value,[`${D}-drop-before`]:M.value,[`${D}-drop-inside`]:$.value,[`${D}-drop-after`]:q.value}}),re=D=>{var U;D.stopPropagation(),w(D,e.node),(U=D.dataTransfer)==null||U.setData("text/plain","")},le=D=>{D.stopPropagation(),K(D,e.node)},ce=D=>{D.preventDefault(),D.stopPropagation(),I(D,e.node)},se=D=>{D.preventDefault(),D.stopPropagation(),F(D,e.node)},de=D=>{D.stopPropagation(),h(D,e.node)},ue=D=>{D.stopPropagation(),c(D,e.node)};return()=>{var z,ke;const D=new Map;r.value.forEach(te=>{D.set(te.key,te)});const{isLeaf:U,label:Q,level:Z,rawNode:ee,expanded:ie,checkDisabled:fe,dragDisabled:C,dropDisabled:N,node:_}=e,{checkable:H,draggable:R}=t,P=R&&!C,ve=(ke=(z=n.draggableIcon)==null?void 0:z.call(n))!=null?ke:L(V,{name:v.value},null),he=D.get(g.value),ne=[];a.value&&Me(D,he).reverse().forEach((te,Ee)=>{var xe;(xe=D.get(te))!=null&&xe.isLast&&ne.push(Ee)});const ge=t.customAdditional?t.customAdditional({node:ee,level:Z}):void 0;return L("div",be({class:J.value,"aria-grabbed":A.value||void 0,"aria-label":Q,"aria-selected":p.value,draggable:P||void 0,title:Q,onDragstart:P?re:void 0,onDragend:P?le:void 0,onDragenter:P?ce:void 0,onDragover:P?se:void 0,onDragleave:P?de:void 0,onDrop:P&&!N?ue:void 0},ge),[L(wn,{level:Z,noopIdentUnitArr:ne,prefixCls:o.value},null),P?L("span",{class:`${o.value}-node-draggable-icon`},[ve]):R&&L("span",{class:`${o.value}-node-draggable-icon-noop`},null),U&&a.value?L(Kn,null,n):L(xn,{expanded:ie,hasTopLine:d.value,hasBottomLine:u.value,isLeaf:U,nodeKey:g.value,rawNode:ee},n),H&&L(bn,{checkDisabled:fe,node:_},null),L(mn,{disabled:S.value,node:_,nodeKey:g.value,label:Q,selected:p.value},n)])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Le(e){const{heightMd:n,heightSm:t,marginSizeXs:r,colorPrimaryHover:o,colorPrimaryText:a,colorContainerBgHover:l,colorContainerBg:s,colorIconInfo:v}=e;return{dropLineWidth:2,dropLineColor:o,bgColor:s,nodeBgColorHover:l,nodeBgColorSelected:s,nodeColorSelected:a,nodePaddingHorizontal:r,nodePaddingVertical:"0px",nodeContentHeight:n,nodeContentLabelHighlightColor:a,nodeContentPrefixMarginRight:r,nodeCheckboxMarginRight:r,nodeIconWidth:t,expandIconColor:v}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const Sn=(e,n)=>Le(e),Ie={width:0,height:0,display:"flex",overflow:"hidden",opacity:0,border:0,padding:0,margin:0},Dn=W({name:"IxTree",props:vn,setup(e,{attrs:n,expose:t,slots:r}){const o=Ce("common"),{globalHashId:a,hashId:l,registerToken:s}=Oe("tree");s(Sn);const v=x(()=>`${o.prefixCls}-tree`),f=Ce("tree"),b=x(()=>{var C;return(C=e.autoHeight)!=null?C:f.autoHeight}),m=x(()=>{var C;return(C=e.childrenKey)!=null?C:f.childrenKey}),k=_e(e,f),w=x(()=>{var C;return(C=e.labelKey)!=null?C:f.labelKey}),K=x(()=>{var C;return(C=e.showLine)!=null?C:f.showLine}),I=x(()=>{var C;return(C=e.blocked)!=null?C:f.blocked}),F=x(()=>e.checkable&&e.checkOnClick),{mergedNodes:h,mergedNodeMap:c,parentKeyMap:g,depthMap:y,setLoadedNodes:i}=Je(e,m,k,w),{searchedKeys:d}=sn(e,c,w),u=cn(e,f,m,c,d,i),p=Ze(h,u,e,d),S=Ye(e,h,c,g,y),A=an(e,f,u),E=fn(e,c),{handleCheck:T}=S;Ge(G,{props:e,config:f,flattedNodes:p,mergedPrefixCls:v,mergedNodeMap:c,mergedGetKey:k,mergedShowLine:K,mergedCheckOnClick:F,searchedKeys:d,...S,...u,...A,...E});const M=O(),$=O(),{activeKey:q}=E,{focused:J,handleFocus:re,handleBlur:le,handleKeydown:ce,handleKeyup:se}=ln(e,c,p,u,E),de=x(()=>{const C=v.value;return{[a.value]:!!a.value,[l.value]:!!l.value,[C]:!0,[`${C}-active`]:!j(q.value),[`${C}-blocked`]:I.value,[`${C}-virtual`]:e.virtual,[`${C}-auto-height`]:b.value,[`${C}-focused`]:J.value,[`${C}-show-line`]:K.value,[`${C}-empty`]:!p.value.length}}),ue=x(()=>{var R,P;const C=q.value;if(j(C))return"";const N=c.value;let _=String(C),H=(R=N.get(C))==null?void 0:R.parentKey;for(;H;)_=`${String(H)} > ${_}`,H=(P=N.get(H))==null?void 0:P.parentKey;return _}),D=C=>{var N;(N=M==null?void 0:M.value)==null||N.focus(C)},U=()=>{var C;(C=M==null?void 0:M.value)==null||C.blur()},Q=C=>{var N;(N=$.value)==null||N.scrollTo(C)},Z=C=>{var N;return(N=c.value.get(C))==null?void 0:N.rawNode},ee=()=>p.value,ie=C=>{const N=c.value.get(C);N&&T(N)};t({focus:D,blur:U,expandAll:u.expandAll,collapseAll:u.collapseAll,scrollTo:Q,getNode:Z,_getFlattedNodes:ee,_handleCheck:ie});const fe=(C,N,_)=>{B(e.onScrolledChange,C,N,_.map(H=>H.rawNode))};return()=>{var _;const C=p.value;let N;if(C.length>0){const H=({item:z})=>L(Ae,be({node:z},z),r),{height:R,virtual:P,virtualItemHeight:ve,virtualScrollMode:he,onScroll:ne,onScrolledBottom:ge}=e;N=P?L(He,{ref:$,class:`${v.value}-content`,dataSource:C,getKey:"key",height:b.value?"100%":R,rowHeight:ve,rowRender:H,virtual:!0,scrollMode:he,onScroll:ne,onScrolledBottom:ge,onScrolledChange:fe},null):L("div",{class:`${v.value}-content`,style:Qe(b.value?void 0:{maxHeight:qe(R)})},[L("div",{class:`${v.value}-content-inner`},[C.map(z=>L(Ae,be({node:z},z),r))])])}else N=L(je,{empty:e.empty},r);return L("div",{class:de.value,role:"tree"},[J.value&&L("span",{style:Ie,"aria-live":"assertive"},[ue.value]),L("input",{ref:M,style:Ie,tabindex:(_=n.tabIndex)!=null?_:0,onFocus:re,onBlur:le,onKeydown:ce,onKeyup:se,value:"","aria-label":"for screen reader"},null),N])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const Mn=Dn;export{Mn as I,Xe as a,Fn as b,Nn as f,pe as g,In as m,oe as t,Se as u};

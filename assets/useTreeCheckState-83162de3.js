import{d as N,S as F,c as T,b as q,r as W,w as X,au as G}from"./vendor-fe119cfa.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function U(d,r,o,u="pre"){const v=(c,a)=>{for(let M=0;M<c.length;M++){const p=c[M];u==="pre"&&o(p,a),p[r]&&v(p[r],[p,...a]),u==="post"&&o(p,a)}};v(d,[])}function $(d,r,o){const u=(v,c)=>{const a=[];for(let M=0;M<v.length;M++){const p=v[M],h=o(p,c,M);if(h){if(p[r]){const A=u(p[r],[p,...c]);h[r]=A}a.push(h)}}return a};return u(d,[])}function Y(d,r,o,u="or"){const v=(c,a)=>{var p;const M=[];for(let h=0;h<c.length;h++){let A;const E=c[h];E[r]&&(A=v(E[r],[E,...a]));let g=o(E,a,A);const D=A&&A.length>0||!((p=E[r])!=null&&p.length)&&g;g=u==="and"?D&&g:D||g,g&&M.push({...E,[r]:E[r]&&A})}return M};return v(d,[])}function j(d,r,o,u){var c;const v=d.map(a=>({...a}));for(const a of r){const M=v.find(p=>{const h=u(a),A=u(p);return!N(h)&&!N(A)&&h===A});if(!M){v.push({...a});continue}for(const p of[...Object.getOwnPropertyNames(a),...Object.getOwnPropertySymbols(a)])p!==o&&(M[p]=a[p]);F(a[o])&&(M[o]=j((c=M[o])!=null?c:[],a[o],o,u))}return v}function y(d,r,o,u=!1){const v=[];return U(d,r,c=>{if(!u||!c[r]||c[r].length<=0){const a=o?o(c):c;a&&v.push(a)}}),v}function B(d,r,o,u=!1){const v=[];return U(d,r,c=>{var a;(!u||!((a=c[r])!=null&&a.length))&&v.push(o(c))}),v}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function H(d,r,o,u){const v=n=>F(n)?J(n,r.value,o.value):n,c=T(()=>{var n;return(n=u==null?void 0:u.value)!=null?n:"all"}),a=T(()=>v(d.value)),M=(n,f)=>{const{parentKeyMap:w,dataMap:i}=f,e=[];let s=n;for(;w.has(s);){const l=w.get(s),t=i.get(l);t&&e.push(t),s=l}return e},p=()=>{const{data:n,parentKeyMap:f,dataMap:w}=a.value;if(n)return n;const i=[];for(const e of f.keys())!f.has(e)&&w.has(e)&&i.push(w.get(e));return i},h=(n,f,w)=>{if(!f.length)return Array.from(n);if(c.value==="off")return Array.from(new Set([...n,...f]));const{dataMap:i}=w,e=new Set(n);return f.forEach(s=>{if(!i.has(s))return;const l=i.get(s);B([l],r.value,o.value,c.value==="child").forEach(t=>{e.add(t)})}),c.value==="child"?Array.from(e).filter(s=>{var l,t;return!((t=(l=i.get(s))==null?void 0:l[r.value])!=null&&t.length)}):(f.forEach(s=>{M(s,w).forEach(l=>{var t;(t=l[r.value])!=null&&t.every(m=>e.has(o.value(m)))&&e.add(o.value(l))})}),c.value==="all"||e.forEach(s=>{var t;if(!e.has(s))return;const l=(t=i.get(s))==null?void 0:t[r.value];l&&U(l,r.value,m=>{e.delete(o.value(m))})}),Array.from(e))},A=(n,f,w)=>{if(!f.length)return Array.from(n);const i=new Set(n);if(c.value==="off")return f.forEach(t=>{i.delete(t)}),Array.from(i);const{dataMap:e}=w,s=new Set,l=t=>{s.add(t),i.delete(t)};return f.forEach(t=>{if(!e.has(t))return;B([e.get(t)],r.value,o.value).forEach(S=>{l(S)});const m=M(t,w);if(c.value==="parent"){const C=[t,...m.map(o.value)].findIndex(_=>i.has(_));C>-1&&m.slice(0,C).forEach(_=>{_[r.value]&&(_[r.value].forEach(I=>{const k=o.value(I);s.has(k)||i.add(k)}),l(o.value(_)))})}else m.forEach(S=>{l(o.value(S))})}),Array.from(i)},E=(n,f)=>h(n,f,a.value),g=(n,f)=>A(n,f,a.value),D=(n,f)=>{const w=n!=null?n:p(),i=c.value==="parent"?w.map(o.value):new Set(B(w,r.value,o.value,c.value==="child"));return A(i,f,n?v(n):a.value)},x=(n,f)=>h([],f,n?v(n):a.value);return{appendKeys:E,removeKeys:g,getAllCheckedKeys:(n,f)=>{const w=(i=>q(i==null?void 0:i[0]))(n);return D(w?n:void 0,f!=null?f:w?[]:n!=null?n:[])},getAllUncheckedKeys:(n,f)=>{const w=(i=>q(i==null?void 0:i[0]))(n);return x(w?n:void 0,f!=null?f:w?[]:n!=null?n:[])}}}function J(d,r,o){const u=new Map,v=new Map,c=new Map;return U(d,r,(a,M)=>{const p=o(a),h=M[0];u.set(p,a),c.set(p,M.length),h&&v.set(p,o(h))}),{data:d,dataMap:u,parentKeyMap:v,depthMap:c}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function K(d,r,o,u,v,c){const a=W([]),M=T(()=>J(a.value,o.value,u.value)),p=T(()=>{const{data:e,dataMap:s,parentKeyMap:l,depthMap:t}=r.value,{data:m,dataMap:S,parentKeyMap:C,depthMap:_}=M.value,I=j(e!=null?e:[],m!=null?m:[],o.value,u.value),k=new Map(s),P=new Map(S);k.forEach((z,b)=>{if(P.has(b)){const Q=P.get(b);k.set(b,j([z],[Q],o.value,u.value)[0]),P.delete(b)}}),P.forEach((z,b)=>{k.set(b,z)});const L=new Map([...C,...l]),O=new Map([..._,...t]);return{data:I,dataMap:k,parentKeyMap:L,depthMap:O}}),h=H(p,o,u,v),A=H(p,o,u,T(()=>"all")),E=T(()=>{const{dataMap:e}=p.value,s=new Set;return e.forEach((l,t)=>{var m;(m=c.value)!=null&&m.call(c,l)&&s.add(t)}),s}),g=T(()=>{const e=v.value==="off"?d.value:A.appendKeys([],d.value);return new Set(e)}),D=T(()=>{const{parentKeyMap:e}=p.value,s=g.value;if(s.size===0||v.value==="off")return new Set;const l=new Set;return s.forEach(t=>{let m=e.get(t);if(!N(m)&&!s.has(m))for(;!N(m);)l.add(m),m=e.get(m)}),l});X([d,v],()=>{const{data:e}=p.value,s=g.value;a.value=Y(e,o.value,l=>s.has(u.value(l)),"or")});const x=e=>E.value.has(e),R=e=>g.value.has(e),V=e=>D.value.has(e),n=e=>{var I;const s=u.value(e);if(x(s))return{checked:R(s),checkedKeys:d.value};const l=v.value!=="off"?(I=e[o.value])!=null?I:[]:[],t=R(s)||!!l.length&&l.every(k=>{const P=u.value(k);return R(P)||V(P)||x(P)}),m=h.appendKeys([],d.value),S=h[t?"removeKeys":"appendKeys"](m,[s]),C=t?[...g.value].filter(k=>x(k)):(v.value==="parent"?A.appendKeys([],S):S).filter(k=>x(k)&&!g.value.has(k)),_=h[t?"appendKeys":"removeKeys"](S,C);return{checked:!t,checkedKeys:_}},f=(e,s,l)=>{var _;const t=(I=>F(I)&&q(I==null?void 0:I[0]))(e),m=(_=t?G(s)?[]:s:e)!=null?_:[],S=t?G(s)?s:l:void 0,C=t?S?j(e,a.value,o.value,u.value):e:[];return{dataProvided:t,data:C,defaultKeys:m,cached:S}};return{allCheckedKeySet:g,checkDisabledKeySet:E,checkStateResolver:h,isChecked:R,isCheckDisabled:x,isIndeterminate:V,toggle:n,getAllCheckedKeys:(e,s,l)=>{const t=f(e,s,l);return t.dataProvided?h.getAllCheckedKeys(t.data,t.defaultKeys):h.getAllCheckedKeys(t.defaultKeys)},getAllUncheckedKeys:(e,s,l)=>{const t=f(e,s,l);return t.dataProvided?h.getAllUncheckedKeys(t.data,t.defaultKeys):h.getAllCheckedKeys(t.defaultKeys)}}}export{H as a,j as b,y as c,Y as f,B as g,$ as m,U as t,K as u};

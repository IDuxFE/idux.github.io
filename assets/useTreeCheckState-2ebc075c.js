import{aX as J,b0 as z,b1 as B,q as Z}from"./index-974a2c75.js";import{c as C,k as L,b as F,r as $,d as N,w as X,ah as G}from"./vendor-e200cecb.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function H(w,d,l,h){const m=t=>L(t)?Q(t,d.value,l.value):t,i=C(()=>{var t;return(t=h==null?void 0:h.value)!=null?t:"all"}),A=C(()=>m(w.value)),T=(t,n)=>{const{parentKeyMap:c,dataMap:s}=n,u=[];let f=t;for(;c.has(f);){const p=c.get(f),e=s.get(p);e&&u.push(e),f=p}return u},g=()=>{const{data:t,parentKeyMap:n,dataMap:c}=A.value;if(t)return t;const s=[];for(const u of n.keys())!n.has(u)&&c.has(u)&&s.push(c.get(u));return s},M=(t,n,c)=>{if(!n.length)return Array.from(t);if(i.value==="off")return Array.from(new Set([...t,...n]));const{dataMap:s}=c,u=new Set(t);return n.forEach(f=>{if(!s.has(f))return;const p=s.get(f);z([p],d.value,l.value,i.value==="child").forEach(e=>{u.add(e)})}),i.value==="child"?Array.from(u).filter(f=>{var p,e;return!((e=(p=s.get(f))==null?void 0:p[d.value])!=null&&e.length)}):(n.forEach(f=>{T(f,c).forEach(p=>{var e;(e=p[d.value])!=null&&e.every(a=>u.has(l.value(a)))&&u.add(l.value(p))})}),i.value==="all"||u.forEach(f=>{var e;if(!u.has(f))return;const p=(e=s.get(f))==null?void 0:e[d.value];p&&J(p,d.value,a=>{u.delete(l.value(a))})}),Array.from(u))},b=(t,n,c)=>{if(!n.length)return Array.from(t);const s=new Set(t);if(i.value==="off")return n.forEach(e=>{s.delete(e)}),Array.from(s);const{dataMap:u}=c,f=new Set,p=e=>{f.add(e),s.delete(e)};return n.forEach(e=>{if(!u.has(e))return;z([u.get(e)],d.value,l.value).forEach(v=>{p(v)});const a=T(e,c);if(i.value==="parent"){const r=[e,...a.map(l.value)].findIndex(o=>s.has(o));r>-1&&a.slice(0,r).forEach(o=>{o[d.value]&&(o[d.value].forEach(k=>{const D=l.value(k);f.has(D)||s.add(D)}),p(l.value(o)))})}else a.forEach(v=>{p(l.value(v))})}),Array.from(s)},K=(t,n)=>M(t,n,A.value),_=(t,n)=>b(t,n,A.value),y=(t,n)=>{const c=t!=null?t:g(),s=i.value==="parent"?c.map(l.value):new Set(z(c,d.value,l.value,i.value==="child"));return b(s,n,t?m(t):A.value)},U=(t,n)=>M([],n,t?m(t):A.value);return{appendKeys:K,removeKeys:_,getAllCheckedKeys:(t,n)=>{const c=(s=>F(s==null?void 0:s[0]))(t);return y(c?t:void 0,n!=null?n:c?[]:t!=null?t:[])},getAllUncheckedKeys:(t,n)=>{const c=(s=>F(s==null?void 0:s[0]))(t);return U(c?t:void 0,n!=null?n:c?[]:t!=null?t:[])}}}function Q(w,d,l){const h=new Map,m=new Map,i=new Map;return J(w,d,(A,T)=>{const g=l(A),M=T[0];h.set(g,A),i.set(g,T.length),M&&m.set(g,l(M))}),{data:w,dataMap:h,parentKeyMap:m,depthMap:i}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function te(w,d,l,h,m,i){const A=$([]),T=C(()=>Q(A.value,l.value,h.value)),g=C(()=>{const{data:e,dataMap:a,parentKeyMap:v,depthMap:r}=d.value,{data:o,dataMap:k,parentKeyMap:D,depthMap:I}=T.value,E=B(e!=null?e:[],o!=null?o:[],l.value,h.value),S=new Map(a),P=new Map(k);S.forEach((q,R)=>{if(P.has(R)){const Y=P.get(R);S.set(R,B([q],[Y],l.value,h.value)[0]),P.delete(R)}}),P.forEach((q,R)=>{S.set(R,q)});const V=new Map([...D,...v]),W=new Map([...I,...r]);return{data:E,dataMap:S,parentKeyMap:V,depthMap:W}}),M=H(g,l,h,m),b=H(g,l,h,C(()=>"all")),K=C(()=>{const{dataMap:e}=g.value,a=new Set;return e.forEach((v,r)=>{var o;(o=i.value)!=null&&o.call(i,v)&&a.add(r)}),a}),_=C(()=>{const e=m.value==="off"?w.value:b.appendKeys([],w.value);return new Set(e)}),y=C(()=>w.value.filter(e=>!_.value.has(e))),U=C(()=>{const{parentKeyMap:e}=g.value,a=_.value;if(a.size===0||m.value==="off")return new Set;const v=new Set;return a.forEach(r=>{let o=e.get(r);if(!N(o)&&!a.has(o))for(;!N(o);)v.add(o),o=e.get(o)}),v}),j=()=>{const{data:e}=g.value,a=_.value;A.value=Z(e,l.value,v=>a.has(h.value(v)),"or")};X([w,m],j),X(y,(e,a)=>{e.length!==a.length&&j()});const x=e=>K.value.has(e),t=e=>_.value.has(e),n=e=>U.value.has(e),c=e=>y.value?[...e,...y.value]:e,s=e=>{var E;const a=h.value(e);if(x(a))return{checked:t(a),checkedKeys:w.value};const v=m.value!=="off"?(E=e[l.value])!=null?E:[]:[],r=t(a)||!!v.length&&v.every(S=>{const P=h.value(S);return t(P)||n(P)||x(P)}),o=M.appendKeys([],w.value),k=M[r?"removeKeys":"appendKeys"](o,[a]),D=r?[..._.value].filter(S=>x(S)):(m.value==="parent"?b.appendKeys([],k):k).filter(S=>x(S)&&!_.value.has(S)),I=c(M[r?"appendKeys":"removeKeys"](k,D));return{checked:!r,checkedKeys:I}},u=(e,a,v)=>{var I;const r=(E=>L(E)&&F(E==null?void 0:E[0]))(e),o=(I=r?G(a)?[]:a:e)!=null?I:[],k=r?G(a)?a:v:void 0,D=r?k?B(e,A.value,l.value,h.value):e:[];return{dataProvided:r,data:D,defaultKeys:o,cached:k}};return{allCheckedKeySet:_,checkDisabledKeySet:K,checkStateResolver:M,isChecked:t,isCheckDisabled:x,isIndeterminate:n,toggle:s,getAllCheckedKeys:(e,a,v)=>{const r=u(e,a,v),o=r.dataProvided?M.getAllCheckedKeys(r.data,r.defaultKeys):M.getAllCheckedKeys(r.defaultKeys);return c(o)},getAllUncheckedKeys:(e,a,v)=>{const r=u(e,a,v);return r.dataProvided?M.getAllUncheckedKeys(r.data,r.defaultKeys):M.getAllCheckedKeys(r.defaultKeys)}}}export{H as a,te as u};

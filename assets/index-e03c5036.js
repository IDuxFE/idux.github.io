import{m as L,al as Y,ao as $e,k as Ie,A as _,a6 as Ne,L as ge,ar as Be,H as Ee,aJ as Pe,aq as Te}from"./index-d79199e1.js";import{k as P,f as x,b as E,N as Oe,w as qe,P as Ue,v as R,y as K,i as W,O as je,z as ze,a2 as se,p as He,B as Me}from"./vendor-50817465.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Q(e,n,o){if(o){const a=[],t=e.value;n.forEach(l=>{const r=t.get(l);r&&a.push(r.rawNode)}),L(o,n,a)}}function X(e,n){const o=[],{children:a}=e||{};return a&&a.forEach(t=>{const{key:l}=t;n!=null&&n.includes(l)||o.push(t.key),o.push(...X(t,n))}),o}function Z(e,n,o){const a=[];for(;n&&!P(n.parentKey);){const{parentKey:t}=n;o!=null&&o.includes(n.parentKey)||a.push(t),n=e.get(t)}return a}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function _e(e,n){const[o,a]=Y(e,"checkedKeys",()=>[]),t=x(()=>{const s=[];return e.checkable&&n.value.forEach((u,i)=>{u.checkDisabled&&s.push(i)}),s}),l=x(()=>e.cascaderStrategy!=="off"?Ve(n.value,o.value,t.value):o.value),r=x(()=>{const s=l.value;if(s.length===0||e.cascaderStrategy==="off")return[];const u=new Set,i=n.value;return s.forEach(f=>{const{parentKey:b}=i.get(f)||{};if(!P(b)){let k=i.get(b);if(k&&!s.includes(k.key))for(u.add(b);k&&!P(k.parentKey);)u.add(k.parentKey),k=i.get(k.parentKey)}}),[...u]}),c=s=>{const u=s.key,i=n.value,f=t.value,b=e.cascaderStrategy,k=b!=="off",m=k?X(s,f):[],F=l.value.indexOf(u);let C=[...l.value];const g=F>-1||!!m.length&&m.every(y=>C.includes(y)||r.value.includes(y));if(g){const y=k?Z(i,s,f):[];C.splice(F,1),C=C.filter(D=>!y.includes(D)&&!m.includes(D))}else C.push(u),k&&xe(i,s,C,f),C.push(...m);v(g,s.rawNode,Re(b,C,i,f))},v=(s,u,i)=>{const{onCheck:f,onCheckedChange:b}=e;L(f,!s,u),a(i),Q(n,i,b)};return{checkedKeys:o,allCheckedKeys:l,checkDisabledKeys:t,indeterminateKeys:r,handleCheck:c}}function xe(e,n,o,a){let t=!0;for(;t&&n&&!P(n.parentKey);){const l=e.get(n.parentKey);l&&!a.includes(n.parentKey)&&(t=l.children.every(r=>a.includes(r.key)||o.includes(r.key)),t&&o.push(n.parentKey)),n=l}}function Re(e,n,o,a){if(e==="off")return[...new Set(n)];let t=[];n=ke(o,n,a),a.length&&(t=n.filter(l=>a.includes(l)));for(const l of n){const r=o.get(l);if(r){const c=r.key,v=r.parentKey;e==="parent"?n.includes(v)||t.push(c):e==="child"?r.isLeaf&&t.push(c):t.push(c)}}return[...new Set(t)]}function Ve(e,n,o){let a=[...n],t;for(const l of n){const r=e.get(l),c=r==null?void 0:r.parentKey,v=X(r,o);a=a.concat(v),!P(c)&&t!==c&&(xe(e,r,a,o),t=c)}return a=ke(e,[...new Set(a)],o),a}function ke(e,n,o){let a=[...n];if(o.length){for(const t of o)if(!a.includes(t)){const l=e.get(t),r=Z(e,l,o);a=a.filter(c=>!r.includes(c))}}return a}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Ge(e,n,o,a){const t=x(()=>Ce(e,e.dataSource,n.value,o.value,a.value)),l=x(()=>{const r=new Map;return de(t.value,r),r});return{mergedNodes:t,mergedNodeMap:l}}function We(e,{expandedKeys:n},o,a){return x(()=>{const{searchValue:t}=o,l=new Map(n.value.map((c,v)=>[c,v])),r=new Map(a.value.map((c,v)=>[c,v]));return t&&!r.size?[]:l.size||r.size?Ye(e.value,l,r):e.value.map(c=>({...c,expanded:!1,level:0}))})}function Ce(e,n,o,a,t,l,r){const{disabled:c,loadChildren:v}=e,s=P(r)?-1:r;return n.map((u,i)=>Ke(u,o,a,t,c,!!v,i===0,i===n.length-1,s,l))}function Ke(e,n,o,a,t,l,r,c,v,s){const u=o(e),{check:i,drag:f,drop:b,select:k}=Je(e,t),m=e[n],F=e[a];v++;const C=m==null?void 0:m.map((g,y)=>Ke(g,n,o,a,t,l,y===0,y===m.length-1,v,u));return{children:C,label:F,key:u,isFirst:r,isLeaf:e.isLeaf??!(C!=null&&C.length||l),isLast:c,parentKey:s,expanded:!1,level:v,rawNode:e,checkDisabled:i,dragDisabled:f,dropDisabled:b,selectDisabled:k}}function Je(e,n){const o=e.disabled||{};if(o===!0)return{check:!0,drag:!0,drop:!0,select:!0};let{check:a,drag:t,drop:l,select:r}=o;if(n){const c=n(e)||{};if(c===!0)return{check:!0,drag:!0,drop:!0,select:!0};a=a||c.check,t=t||c.drag,l=l||c.drop,r=r||c.select}return{check:a,drag:t,drop:l,select:r}}function de(e,n){e.forEach(o=>{const{key:a,children:t}=o;n.set(a,o),t&&de(t,n)})}function me(e=[],n){const o=[],a=e.length;return e.forEach((t,l)=>{t.isFirst=l===0,t.isLast=l===a-1,n.has(t.key)||n.size==0?(t.hidden=!1,o.push(t)):t.hidden=!0,me(t.children,n).length>0&&(t.hidden=!1,o.push(t))}),o.length&&(o[0].isFirst=!0,o[o.length-1].isLast=!0),o}function Ye(e,n,o){const a=[],t=[];return me(e,o),e.forEach(l=>{for(t.push(l);t.length;){const r=t.pop();if(r){const{children:c,key:v,hidden:s}=r,u=n.has(v);if(r.expanded=u,!s&&a.push(r),c&&u)for(let i=c.length;i>0;i--)!c[i-1].hidden&&t.push(c[i-1])}}}),a}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Qe(e,n,{expandedKeys:o,setExpandedKeys:a}){const t=x(()=>e.draggableIcon??n.draggableIcon),l=E(),r=E(),c=E(),v=E(),s=E();let u;const i=()=>{u&&(clearTimeout(u),u=void 0)};Oe(()=>i());const f=()=>{P(l.value)||(l.value=void 0,r.value=void 0)},b=()=>{P(c.value)||(c.value=void 0,v.value=void 0,s.value=void 0)},k=(h,p)=>{var A,$;return{evt:h,node:p.rawNode,dragNode:(A=l.value)==null?void 0:A.rawNode,dropNode:($=c.value)==null?void 0:$.rawNode,dropType:s.value}},m=h=>{C(h,void 0),window.removeEventListener("dragend",m)},F=(h,p)=>{l.value=p,r.value=X(p),Ze(p.key,o.value,a),window.addEventListener("dragend",m),L(e.onDragstart,k(h,p))},C=(h,p)=>{p&&L(e.onDragend,k(h,p)),f(),b()},g=async(h,p)=>{const A=l.value;if(A){i(),A.key!==p.key&&(u=setTimeout(()=>{var I;l.value&&((I=p.children)!=null&&I.length)&&Xe(p.key,o.value,a),u=void 0},1e3));const $=await ye(p,A,r.value,h,e.droppable);$?(c.value=p,v.value=$!=="inside"?p.parentKey:void 0,s.value=$):b()}L(e.onDragenter,k(h,p))},y=async(h,p)=>{const A=l.value;if(A){const $=await ye(p,A,r.value,h,e.droppable);$?(c.value=p,v.value=$!=="inside"?p.parentKey:void 0,s.value=$):b()}L(e.onDragover,k(h,p))},D=(h,p)=>{const A=c.value;(A==null?void 0:A.key)===p.key&&!h.currentTarget.contains(h.relatedTarget)&&b(),L(e.onDragleave,k(h,p))},S=(h,p)=>{s.value||b(),L(e.onDrop,k(h,p)),f(),b()};return{draggableIcon:t,dragKey:x(()=>{var h;return(h=l.value)==null?void 0:h.key}),dropKey:x(()=>{var h;return(h=c.value)==null?void 0:h.key}),dropParentKey:v,dropType:s,handleDragstart:F,handleDragend:C,handleDragenter:g,handleDragover:y,handleDragleave:D,handleDrop:S}}function Xe(e,n,o){n.indexOf(e)===-1&&o([...n,e])}function Ze(e,n,o){const a=n.indexOf(e);if(a!==-1){const t=[...n];t.splice(a,1),o(t)}}async function ye(e,n,o,a,t){const{key:l,children:r=[]}=e;if(n.key===l||o&&o.includes(l))return!1;const{clientY:c}=a,{top:v,height:s}=a.target.getBoundingClientRect(),u=c<v+s/2;let i;if(t){const f={evt:a,isTopHalf:u,dragNode:n.rawNode,dropNode:e.rawNode};i=await t(f)}return(i===void 0||i===!0)&&(r.length>0?i="inside":u?i="before":i="after"),i}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function en(e,n,o,{expandedKeys:a,handleExpand:t},{activeKey:l,handleSelect:r}){const c=E(!1);return{focused:c,handleFocus:f=>{c.value=!0,L(e.onFocus,f)},handleBlur:f=>{c.value=!0,L(e.onBlur,f)},handleKeydown:f=>{switch(f.code){case"ArrowUp":case"ArrowDown":f.preventDefault()}L(e.onKeydown,f)},handleKeyup:f=>{const b=f.code,k=l.value,m=o.value,F=m.length;if(k===void 0)["ArrowDown","ArrowUp","ArrowLeft","ArrowRight"].includes(b)&&ce(l,m,0,F);else{const C=o.value,g=C.findIndex(y=>y.key===k);if(g===-1)return;switch(b){case"Enter":case"NumpadEnter":r(k);break;case"ArrowDown":ce(l,C,g+1,F);break;case"ArrowUp":ce(l,C,g-1,0,!0);break;case"ArrowLeft":{const{rawNode:y,key:D,parentKey:S}=C[g];if(y.isLeaf||!a.value.includes(D)){const h=S?n.value.get(S):void 0;h&&(l.value=h.key)}else t(D,y)}break;case"ArrowRight":{const{rawNode:y,key:D}=C[g];if(!a.value.includes(D))t(D,y);else for(let S=g+1;S<F;S++){const h=C[S];l.value=h.key;break}}break}}L(e.onKeyup,f)}}}function ce(e,n,o,a,t=!1){let l=o;for(;t?l>=a:l<a;){const r=n[l];if(r.selectDisabled)t?l--:l++;else{e.value=r.key;return}}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function nn(e,n,o,a,t,l,r){const c=x(()=>e.expandIcon??n.expandIcon),[v,s]=Y(e,"expandedKeys",()=>[]),[u,i]=Y(e,"loadedKeys",()=>[]),f=E([]),b=g=>{if(!g||g.length<=0)return;const{onExpandedChange:y}=e,D=l.value,S=new Set(v.value);g.forEach(p=>{Z(D,D.get(p)).forEach(A=>S.add(A))});const h=[...S];s(h),Q(l,h,y)};qe(r,b);const k=async(g,y)=>{var $;const{loadChildren:D}=e;if(f.value.includes(g))return;const S=o.value;if(!(($=y==null?void 0:y[S])!=null&&$.length)){if(!D||f.value.includes(g)||u.value.includes(g))return;f.value.push(g);const I=await D(y);f.value.splice(f.value.indexOf(g),1);const j=l.value,O=j.get(g);if(I!=null&&I.length){const G=O.level,z=Ce(e,I,S,a.value,t.value,g,G);de(z,j),O.rawNode[S]=I,O.children=z;const H=[...u.value,g];i(H),L(e.onLoaded,H,y)}else return}const h=v.value.indexOf(g),p=h>=0,A=[...v.value];p?A.splice(h,1):A.push(g),m(p,y,A)},m=(g,y,D)=>{const{onExpand:S,onExpandedChange:h}=e;L(S,!g,y),s(D),Q(l,D,h)},F=()=>{const g=[],y=[];l.value.forEach(D=>{D.isLeaf||(g.push(D.key),y.push(D.rawNode))}),L(e.onExpandedChange,g,y),s(g)},C=()=>{L(e.onExpandedChange,[],[]),s([])};return r.value.length&&b(r.value),{expandIcon:c,expandedKeys:v,setExpandedKeys:s,expandAll:F,collapseAll:C,handleExpand:k,loadingKeys:f}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function tn(e,n,o){const a=an(e,o);return{searchedKeys:x(()=>{const{searchValue:l}=e;if(!l)return $e;const r=a.value,c=[];return n.value.forEach(v=>{r(v.rawNode,l)&&c.push(v.key)}),c})}}function an(e,n){return x(()=>e.searchFn??on(n.value))}function on(e){return(n,o)=>{const a=n[e];return a?a.toLowerCase().includes(o.toLowerCase()):!1}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function ln(e,n){const[o,a]=Y(e,"selectedKeys",()=>[]),t=x(()=>e.selectable==="multiple"),l=E();Ue(()=>{const s=o.value,u=s.length;l.value=u>0?s[u-1]:void 0});const r=x(()=>{const s=l.value;return s!==void 0?n.value.get(s):void 0}),c=s=>{const i=n.value.get(s);if(!i)return;const f=o.value.indexOf(s),b=f>-1;let k=[...o.value];t.value?b?k.splice(f,1):k.push(s):k=b?[]:[s],v(b,i.rawNode,k)},v=(s,u,i)=>{const{onSelect:f,onSelectedChange:b}=e,k=i.includes(u.key??"")?!0:!s;L(f,k,u),a(i),Q(n,i,b)};return{activeKey:l,activeNode:r,selectedKeys:o,handleSelect:c}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const V=Symbol("treeToken");/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const rn={autoHeight:{type:Boolean,default:void 0},checkedKeys:Array,expandedKeys:Array,indeterminateKeys:Array,loadedKeys:Array,selectedKeys:Array,blocked:{type:Boolean,default:void 0},cascaderStrategy:{type:String,default:"off"},checkable:{type:Boolean,default:!1},childrenKey:String,checkOnClick:{type:Boolean,default:!1},customAdditional:{type:Function,default:void 0},dataSource:{type:Array,default:()=>[]},disabled:Function,draggable:{type:Boolean,default:!1},draggableIcon:{type:String,default:void 0},droppable:Function,empty:{type:[String,Object],default:"simple"},expandIcon:{type:[String,Array],default:void 0},getKey:{type:[String,Function],default:void 0},height:Number,labelKey:String,leafLineIcon:String,loadChildren:Function,searchFn:Function,searchValue:String,selectable:{type:[Boolean,String],default:!0},showLine:{type:Boolean,default:void 0},virtual:{type:Boolean,default:!1},"onUpdate:checkedKeys":[Function,Array],"onUpdate:expandedKeys":[Function,Array],"onUpdate:loadedKeys":[Function,Array],"onUpdate:selectedKeys":[Function,Array],onCheck:[Function,Array],onCheckedChange:[Function,Array],onDragstart:[Function,Array],onDragend:[Function,Array],onDragenter:[Function,Array],onDragleave:[Function,Array],onDragover:[Function,Array],onDrop:[Function,Array],onExpand:[Function,Array],onExpandedChange:[Function,Array],onLoaded:[Function,Array],onSelect:[Function,Array],onSelectedChange:[Function,Array],onFocus:[Function,Array],onBlur:[Function,Array],onKeydown:[Function,Array],onKeyup:[Function,Array],onNodeClick:[Function,Array],onNodeContextmenu:[Function,Array],onScroll:[Function,Array],onScrolledChange:[Function,Array],onScrolledBottom:[Function,Array]},cn={node:{type:Object,required:!0},isLeaf:{type:Boolean,required:!0},isFirst:{type:Boolean,required:!0},isLast:{type:Boolean,required:!0},label:String,level:{type:Number,required:!0},rawNode:{type:Object,required:!0},expanded:{type:Boolean,required:!0},children:Array,parentKey:[String,Number,Symbol],checkDisabled:{type:Boolean,default:void 0},dragDisabled:{type:Boolean,default:void 0},dropDisabled:{type:Boolean,default:void 0},selectDisabled:{type:Boolean,default:void 0}},sn={node:{type:Object,required:!0},checkDisabled:{type:Boolean,default:void 0}},dn={expanded:{type:Boolean,required:!0},hasTopLine:{type:Boolean,default:void 0},isLeaf:{type:Boolean,default:void 0},nodeKey:{type:[String,Number,Symbol],required:!0},rawNode:{type:Object,required:!0}},un={disabled:{type:Boolean,default:void 0},node:{type:Object,required:!0},nodeKey:{type:[String,Number,Symbol],required:!0},label:String,selected:{type:Boolean,default:void 0}},fn=R({props:sn,setup(e){const{mergedPrefixCls:n,allCheckedKeys:o,indeterminateKeys:a,handleCheck:t}=W(V),l=x(()=>o.value.includes(e.node.key)),r=x(()=>a.value.includes(e.node.key)),c=()=>t(e.node);return()=>K(Ie,{class:`${n.value}-node-checkbox`,checked:l.value,disabled:e.checkDisabled,indeterminate:r.value,onChange:c},null)}}),hn=R({props:un,setup(e){const{props:n,mergedPrefixCls:o,mergedCheckOnClick:a,slots:t,handleSelect:l,handleCheck:r,searchedKeys:c}=W(V),v=x(()=>c.value.includes(e.nodeKey)),s=i=>{e.disabled||(l(e.nodeKey),a.value&&r(e.node)),L(n.onNodeClick,i,e.node.rawNode)},u=i=>{L(n.onNodeContextmenu,i,e.node.rawNode)};return()=>{var h,p;const{nodeKey:i,label:f,node:b,selected:k}=e,{rawNode:m}=b,{prefix:F,suffix:C}=m,g={key:i,selected:k,node:m},y=((h=t.prefix)==null?void 0:h.call(t,g))||F&&K(_,{name:F},null),D=((p=t.suffix)==null?void 0:p.call(t,g))||C&&K(_,{name:C},null),S=`${o.value}-node-content`;return K("span",{class:S,onClick:s,onContextmenu:u},[y&&K("span",{class:`${S}-prefix`},[y]),K("span",{class:`${S}-label`},[vn(t.label,f,m,n.searchValue,v.value,S)]),D&&K("span",{class:`${S}-suffix`},[D])])}}});function vn(e,n,o,a,t,l){if(e)return e({node:o,searchValue:a,searched:t});if(t&&n&&a){const r=n.toUpperCase().indexOf(a.toUpperCase());if(r>-1){const c=r+a.length,v=n.substring(0,r),s=n.substring(c),u=K("span",{class:`${l}-label-highlight`},[n.substring(r,c)]);return[v,u,s]}}return n}const gn=R({props:dn,setup(e){const{mergedPrefixCls:n,slots:o,expandIcon:a,loadingKeys:t,handleExpand:l}=W(V),r=x(()=>t.value.includes(e.nodeKey)),c=x(()=>{const s=`${n.value}-node-expand`;return ze({[s]:!0,[`${s}-noop`]:e.isLeaf})}),v=s=>{l(e.nodeKey,e.rawNode),s.stopPropagation()};return()=>{const s=`${n.value}-node-expand`;let u;if(r.value)u=K(_,{name:"loading"},null);else if(!e.isLeaf){const{expanded:i}=e;if(o.expandIcon){const{nodeKey:f,rawNode:b}=e;u=o.expandIcon({key:f,expanded:i,node:b})}else{const f=a.value,b=je(f);u=K(_,{name:b?i?f[0]:f[1]:f,rotate:i&&!b?90:0},null)}}return K("span",{class:c.value,onClick:v},[e.hasTopLine&&K("div",{class:`${s}-top-line`},null),u])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const yn=({level:e,noopIdentUnitArr:n,prefixCls:o})=>{const a=[];for(let t=0;t<e;t++)a.push(K("span",{key:t,class:n.includes(t)?`${o}-node-indent-noop-unit`:`${o}-node-indent-unit`},null));return K("span",{"aria-hidden":!0,class:`${o}-node-indent`},[a])},pn=yn,bn=R({setup(){const{props:e,mergedPrefixCls:n,slots:o}=W(V);return()=>{const a=`${n.value}-node-leaf`;let t;return o.leafLineIcon?t=o.leafLineIcon():e.leafLineIcon?t=K(_,{name:e.leafLineIcon},null):t=K("span",{class:`${a}-line`},null),K("span",{class:a},[t])}}}),pe=R({props:cn,setup(e){const{props:n,flattedNodes:o,mergedPrefixCls:a,mergedShowLine:t,activeKey:l,selectedKeys:r,slots:c,draggableIcon:v,dragKey:s,dropKey:u,dropParentKey:i,dropType:f,handleDragstart:b,handleDragend:k,handleDragenter:m,handleDragover:F,handleDragleave:C,handleDrop:g}=W(V),y=Ne(),D=x(()=>l.value===y),S=x(()=>t.value&&e.isLast),h=x(()=>t.value&&!e.isLeaf&&e.level!==0&&e.isFirst),p=x(()=>r.value.includes(y)),A=x(()=>e.selectDisabled||!n.selectable),$=x(()=>s.value===y),I=x(()=>u.value===y),j=x(()=>i.value===y),O=x(()=>I.value&&f.value==="before"),G=x(()=>I.value&&f.value==="inside"),z=x(()=>I.value&&f.value==="after"),H=x(()=>{const d=`${a.value}-node`;return{[d]:!0,[`${d}-active`]:D.value,[`${d}-last`]:S.value,[`${d}-disabled`]:A.value,[`${d}-selected`]:p.value,[`${d}-expanded`]:e.expanded,[`${d}-dragging`]:$.value,[`${d}-dropping`]:I.value,[`${d}-drop-parent`]:j.value,[`${d}-drop-before`]:O.value,[`${d}-drop-inside`]:G.value,[`${d}-drop-after`]:z.value}}),ee=d=>{var w;d.stopPropagation(),b(d,e.node),(w=d.dataTransfer)==null||w.setData("text/plain","")},ne=d=>{d.stopPropagation(),k(d,e.node)},te=d=>{d.preventDefault(),d.stopPropagation(),m(d,e.node)},ae=d=>{d.preventDefault(),d.stopPropagation(),F(d,e.node)},oe=d=>{d.stopPropagation(),C(d,e.node)},le=d=>{d.stopPropagation(),g(d,e.node)};return()=>{var he;const d=new Map;o.value.forEach(J=>{d.set(J.key,J)});const{isLeaf:w,label:B,level:N,rawNode:q,expanded:M,checkDisabled:re,dragDisabled:U,dropDisabled:De,node:ie}=e,{checkable:Se,draggable:ue}=n,T=ue&&!U,Ae=((he=c.draggableIcon)==null?void 0:he.call(c))??K(_,{name:v.value},null),we=d.get(y),fe=[];t.value&&Z(d,we).reverse().forEach((J,Le)=>{var ve;(ve=d.get(J))!=null&&ve.isLast&&fe.push(Le)});const Fe=n.customAdditional?n.customAdditional({node:q,level:N}):void 0;return K("div",se({class:H.value,"aria-grabbed":$.value||void 0,"aria-label":B,"aria-selected":p.value,draggable:T||void 0,title:B,onDragstart:T?ee:void 0,onDragend:T?ne:void 0,onDragenter:T?te:void 0,onDragover:T?ae:void 0,onDragleave:T?oe:void 0,onDrop:T&&!De?le:void 0},Fe),[K(pn,{level:N,noopIdentUnitArr:fe,prefixCls:a.value},null),T?K("span",{class:`${a.value}-node-draggable-icon`},[Ae]):ue&&K("span",{class:`${a.value}-node-draggable-icon-noop`},null),w&&t.value?K(bn,null,null):K(gn,{expanded:M,hasTopLine:h.value,isLeaf:w,nodeKey:y,rawNode:q},null),Se&&K(fn,{checkDisabled:re,node:ie},null),K(hn,{disabled:A.value,node:ie,nodeKey:y,label:B,selected:p.value},null)])}}}),be={width:0,height:0,display:"flex",overflow:"hidden",opacity:0,border:0,padding:0,margin:0},xn=R({name:"IxTree",props:rn,setup(e,{attrs:n,expose:o,slots:a}){const t=ge("common"),l=x(()=>`${t.prefixCls}-tree`),r=ge("tree"),c=x(()=>e.autoHeight??r.autoHeight),v=x(()=>e.childrenKey??r.childrenKey),s=Be(e,r),u=x(()=>e.labelKey??r.labelKey),i=x(()=>e.showLine??r.showLine),f=x(()=>e.blocked??r.blocked),b=x(()=>e.checkable&&e.checkOnClick),{mergedNodes:k,mergedNodeMap:m}=Ge(e,v,s,u),{searchedKeys:F}=tn(e,m,u),C=nn(e,r,v,s,u,m,F),g=We(k,C,e,F),y=_e(e,m),D=Qe(e,r,C),S=ln(e,m);He(V,{props:e,slots:a,config:r,flattedNodes:g,mergedPrefixCls:l,mergedNodeMap:m,mergedGetKey:s,mergedShowLine:i,mergedCheckOnClick:b,searchedKeys:F,...y,...C,...D,...S});const h=E(),p=E(),{activeKey:A}=S,{focused:$,handleFocus:I,handleBlur:j,handleKeydown:O,handleKeyup:G}=en(e,m,g,C,S),z=x(()=>{const d=l.value;return{[d]:!0,[`${d}-active`]:!P(A.value),[`${d}-blocked`]:f.value,[`${d}-virtual`]:e.virtual,[`${d}-auto-height`]:c.value,[`${d}-focused`]:$.value,[`${d}-show-line`]:i.value,[`${d}-empty`]:!g.value.length}}),H=x(()=>{var q,M;const d=A.value;if(P(d))return"";const w=m.value;let B=String(d),N=(q=w.get(d))==null?void 0:q.parentKey;for(;N;)B=`${String(N)} > ${B}`,N=(M=w.get(N))==null?void 0:M.parentKey;return B}),ee=d=>{var w;(w=h==null?void 0:h.value)==null||w.focus(d)},ne=()=>{var d;(d=h==null?void 0:h.value)==null||d.blur()},te=d=>{var w;(w=p.value)==null||w.scrollTo(d)},ae=d=>{var w;return(w=m.value.get(d))==null?void 0:w.rawNode},oe=()=>g.value;o({focus:ee,blur:ne,expandAll:C.expandAll,collapseAll:C.collapseAll,scrollTo:te,getNode:ae,_getFlattedNodes:oe});const le=(d,w,B)=>{L(e.onScrolledChange,d,w,B.map(N=>N.rawNode))};return()=>{const d=g.value;let w;if(d.length>0){const B=({item:U})=>K(pe,se({node:U},U),null),{height:N,virtual:q,onScroll:M,onScrolledBottom:re}=e;w=q?K(Ee,{ref:p,class:`${l.value}-content`,dataSource:d,getKey:"key",height:c.value?"100%":N,itemHeight:28,itemRender:B,virtual:!0,onScroll:M,onScrolledBottom:re,onScrolledChange:le},null):K("div",{class:`${l.value}-content`,style:Me(c.value?void 0:{maxHeight:Pe(N)})},[K("div",{class:`${l.value}-content-inner`},[d.map(U=>K(pe,se({node:U},U),null))])])}else w=K(Te,{empty:e.empty},a);return K("div",{class:z.value,role:"tree"},[$.value&&K("span",{style:be,"aria-live":"assertive"},[H.value]),K("input",{ref:h,style:be,tabindex:n.tabIndex??0,onFocus:I,onBlur:j,onKeydown:O,onKeyup:G,value:"","aria-label":"for screen reader"},null),w])}}});/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */const Kn=xn;export{Kn as I};

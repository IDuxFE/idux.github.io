import{c as T,c5 as G,bU as H,b8 as N,cc as b,aN as z,aP as B,x as F,cd as j,X as L,b7 as X}from"./index-639d4621.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function q(w,p,r,f){const M=e=>H(e)?J(e,p.value,r.value):e,h=T(()=>{var e;return(e=f==null?void 0:f.value)!=null?e:"all"}),A=T(()=>M(w.value)),S=(e,o)=>{const{parentKeyMap:c,dataMap:l}=o,u=[];let g=e;for(;c.has(g);){const a=c.get(g),t=l.get(a);t&&u.push(t),g=a}return u},d=()=>{const{data:e,parentKeyMap:o,dataMap:c}=A.value;if(e)return e;const l=[];for(const u of o.keys())!o.has(u)&&c.has(u)&&l.push(c.get(u));return l},_=(e,o,c)=>{if(!o.length)return Array.from(e);if(h.value==="off")return Array.from(new Set([...e,...o]));const{dataMap:l}=c,u=new Set(e),g=new Set;return o.forEach(a=>{if(!l.has(a)||u.has(a))return;const n=l.get(a)[p.value];u.add(a),g.add(a),n!=null&&n.length&&b(n,p.value,r.value,h.value==="child").forEach(s=>{u.add(s),g.delete(s)})}),h.value==="child"?Array.from(u).filter(a=>{var t,n;return!((n=(t=l.get(a))==null?void 0:t[p.value])!=null&&n.length)}):(g.forEach(a=>{S(a,c).forEach(t=>{var n;(n=t[p.value])!=null&&n.every(s=>u.has(r.value(s)))&&u.add(r.value(t))})}),h.value==="all"||u.forEach(a=>{var n;if(!u.has(a))return;const t=(n=l.get(a))==null?void 0:n[p.value];t&&G(t,p.value,s=>{u.delete(r.value(s))})}),Array.from(u))},E=(e,o,c)=>{if(!o.length)return Array.from(e);const l=new Set(e);if(h.value==="off")return o.forEach(t=>{l.delete(t)}),Array.from(l);const{dataMap:u}=c,g=new Set,a=t=>{g.add(t),l.delete(t)};return o.forEach(t=>{if(!u.has(t))return;b([u.get(t)],p.value,r.value).forEach(s=>{a(s)});const n=S(t,c);if(h.value==="parent"){const v=[t,...n.map(r.value)].findIndex(i=>l.has(i));v>-1&&n.slice(0,v).forEach(i=>{i[p.value]&&(i[p.value].forEach(k=>{const y=r.value(k);g.has(y)||l.add(y)}),a(r.value(i)))})}else n.forEach(s=>{a(r.value(s))})}),Array.from(l)},K=(e,o)=>_(e,o,A.value),P=(e,o)=>E(e,o,A.value),U=(e,o)=>{const c=e!=null?e:d(),l=h.value==="parent"?c.map(r.value):new Set(b(c,p.value,r.value,h.value==="child"));return E(l,o,e?M(e):A.value)},D=(e,o)=>_([],o,e?M(e):A.value);return{appendKeys:K,removeKeys:P,getAllCheckedKeys:(e,o)=>{const c=(l=>N(l==null?void 0:l[0]))(e);return U(c?e:void 0,o!=null?o:c?[]:e!=null?e:[])},getAllUncheckedKeys:(e,o)=>{const c=(l=>N(l==null?void 0:l[0]))(e);return D(c?e:void 0,o!=null?o:c?[]:e!=null?e:[])}}}function J(w,p,r){const f=new Map,M=new Map,h=new Map;return G(w,p,(A,S)=>{const d=r(A),_=S[0];f.set(d,A),h.set(d,S.length),_&&M.set(d,r(_))}),{data:w,dataMap:f,parentKeyMap:M,depthMap:h}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function W(w,p,r,f,M,h){const{mergedResolverContext:A,cachedSelectedData:S,checkStateResolver:d,allCheckStateResolver:_,allCheckedKeySet:E,unexistedKeys:K}=Q(w,p,r,f,M),P=T(()=>{const{dataMap:a}=A.value,t=new Set;return a.forEach((n,s)=>{var v;(v=h.value)!=null&&v.call(h,n)&&t.add(s)}),t}),U=T(()=>{const{parentKeyMap:a}=A.value,t=E.value;if(t.size===0||M.value==="off")return new Set;const n=new Set;return t.forEach(s=>{let v=a.get(s);if(!z(v)&&!t.has(v))for(;!z(v);)n.add(v),v=a.get(v)}),n}),D=a=>P.value.has(a),m=a=>E.value.has(a),C=a=>U.value.has(a),e=a=>K.value?[...a,...K.value]:a,o=a=>{var R;const t=f.value(a);if(D(t))return{checked:m(t),checkedKeys:w.value};const n=M.value!=="off"?(R=a[r.value])!=null?R:[]:[],s=m(t)||!!n.length&&n.every(x=>{const I=f.value(x);return m(I)||C(I)||D(I)}),v=d.appendKeys([],w.value),i=d[s?"removeKeys":"appendKeys"](v,[t]),k=s?[...E.value].filter(x=>D(x)):(M.value==="parent"?_.appendKeys([],i):i).filter(x=>D(x)&&!E.value.has(x)),y=e(d[s?"appendKeys":"removeKeys"](i,k));return{checked:!s,checkedKeys:y}},c=(a,t,n)=>{var y;const s=(R=>H(R)&&N(R==null?void 0:R[0]))(a),v=(y=s?X(t)?[]:t:a)!=null?y:[],i=s?X(t)?t:n:void 0,k=s?i?j(a,S.value,r.value,f.value):a:[];return{dataProvided:s,data:k,defaultKeys:v,cached:i}};return{allCheckedKeySet:E,checkDisabledKeySet:P,checkStateResolver:d,isChecked:m,isCheckDisabled:D,isIndeterminate:C,toggle:o,getAllCheckedKeys:(a,t,n)=>{const s=c(a,t,n),v=s.dataProvided?d.getAllCheckedKeys(s.data,s.defaultKeys):d.getAllCheckedKeys(s.defaultKeys);return e(v)},getAllUncheckedKeys:(a,t,n)=>{const s=c(a,t,n),v=s.dataProvided?d.getAllUncheckedKeys(s.data,s.defaultKeys):d.getAllUncheckedKeys(s.defaultKeys);return e(v)},getDataByKeys:a=>{const{dataMap:t}=A.value;return a.map(n=>t.get(n)).filter(Boolean)}}}function Q(w,p,r,f,M){const h=B([]),A=T(()=>J(h.value,r.value,f.value)),S=B(p.value),d=B(new Set),_={value:[]},E=q(S,r,f,M),K=q(S,r,f,T(()=>"all")),P=()=>{U();const{data:m,dataMap:C,parentKeyMap:e,depthMap:o}=p.value,{data:c,dataMap:l,parentKeyMap:u,depthMap:g}=A.value,a=j(m!=null?m:[],c!=null?c:[],r.value,f.value),t=new Map(C),n=new Map(l);t.forEach((i,k)=>{if(n.has(k)){const y=n.get(k);t.set(k,j([i],[y],r.value,f.value)[0]),n.delete(k)}}),n.forEach((i,k)=>{t.set(k,i)});const s=new Map([...u,...e]),v=new Map([...g,...o]);S.value={data:a,dataMap:t,parentKeyMap:s,depthMap:v}},U=()=>{const{data:m}=S.value,C=d.value;h.value=L(m!=null?m:[],r.value,e=>C.has(f.value(e)),"or")},D=()=>{const m=M.value==="off"?w.value:K.appendKeys([],w.value),C=new Set(m);d.value=C;const e=w.value.filter(o=>!C.has(o));_.value=e};return F(p,P),F([w,S,M],D,{immediate:!0}),{mergedResolverContext:S,cachedSelectedData:h,checkStateResolver:E,allCheckStateResolver:K,allCheckedKeySet:d,unexistedKeys:_}}export{q as a,W as u};

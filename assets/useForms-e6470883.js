var f=Object.defineProperty;var b=(a,s,t)=>s in a?f(a,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[s]=t;var c=(a,s,t)=>(b(a,typeof s!="symbol"?s+"":s,t),t);import{b0 as n,c as w,H as o,x as V,b1 as i,b2 as y}from"./index-da4385ef.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */class C extends n{constructor(t,e,r){super(t,e,r);c(this,"length");this.length=w(()=>this._controls.value.length),this._watchValue(),this._watchStatus(),this._watchBlurred(),this._watchDirty()}setValue(t,e){t.forEach((r,l)=>{const u=this.at(l);u&&u.setValue(r,e)}),e!=null&&e.validate&&this._validate()}getValue(t={}){const{skipDisabled:e}=t;return this._controls.value.filter(l=>!e||!l.disabled.value).map(l=>l.getValue(t))}_calculateInitValue(){return this.getValue()}_forEachControls(t){this._controls.value.forEach(t)}_find(t){return this.at(t)}at(t){return this._controls.value[t]}push(t){t.setParent(this),this._controls.value=[...this._controls.value,t]}insert(t,e){e.setParent(this);const r=[...this._controls.value];r.splice(t,0,e),this._controls.value=r}removeAt(t){const e=[...this._controls.value];e.splice(t,1),this._controls.value=e}clearControls(){this._controls.value=[]}setControl(t,e){e.setParent(this);const r=[...this._controls.value];r.splice(t,1,e),this._controls.value=r}_watchValue(){o(()=>{this._valueRef.value=this.getValue()})}_watchStatus(){o(()=>{this._status.value=this._errors.value?"invalid":"valid"}),o(()=>{let t="valid";const e=this._controls.value;for(const r of e){const l=r.status.value;if(l==="invalid"){t="invalid";break}else l==="validating"&&(t="validating")}this._controlsStatus.value=t})}_watchBlurred(){o(()=>{let t=!1;const e=this._controls.value;for(const r of e)if(r.blurred.value){t=!0;break}this._blurred.value=t})}_watchDirty(){o(()=>{let t=!1;const e=this._controls.value;for(const r of e)if(r.dirty.value){t=!0;break}this._dirty.value=t})}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */class h extends n{constructor(s,t,e){super(void 0,t,e,s),this._initValue=s,this._watchStatus()}setValue(s,t={}){this._valueRef.value=s,t.dirty&&this.markAsDirty(),t.blur&&this.markAsBlurred(),t.validate&&this._validate()}getValue(){return this._valueRef.value}_calculateInitValue(){return this._initValue}_forEachControls(s){}_find(s){}_watchStatus(){V(this._errors,s=>{this._status.value=s?"invalid":"valid"})}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */class v extends n{constructor(s,t,e){super(s,t,e),this._watchValue(),this._watchStatus(),this._watchBlurred(),this._watchDirty()}setValue(s,t){const e=this._controls.value;Object.keys(s).forEach(r=>{const l=e[r];l&&l.setValue(s[r],t)}),t!=null&&t.validate&&this._validate()}getValue(s={}){const{skipDisabled:t}=s,e={};return this._forEachControls((r,l)=>{t&&r.disabled.value||(e[l]=r.getValue(s))}),e}_calculateInitValue(){return this.getValue()}_forEachControls(s){const t=this._controls.value;Object.keys(t).forEach(e=>s(t[e],e))}_find(s){const t=this._controls.value;return i(t,s)?t[s]:void 0}addControl(s,t){const e={...this._controls.value};i(e,s)||(t.setParent(this),e[s]=t,this._controls.value=e)}removeControl(s){const t={...this._controls.value};delete t[s],this._controls.value=t}setControl(s,t){t.setParent(this);const e={...this._controls.value};e[s]=t,this._controls.value=e}_watchValue(){o(()=>{this._valueRef.value=this.getValue()})}_watchStatus(){o(()=>{this._status.value=this._errors.value?"invalid":"valid"}),o(()=>{let s="valid";const t=this._controls.value;for(const e in t){if(!i(t,e))continue;const r=t[e].status.value;if(r==="invalid"){s="invalid";break}else r==="validating"&&(s="validating")}this._controlsStatus.value=s})}_watchBlurred(){o(()=>{let s=!1;const t=this._controls.value;for(const e in t)if(i(t,e)&&t[e].blurred.value){s=!0;break}this._blurred.value=s})}_watchDirty(){o(()=>{let s=!1;const t=this._controls.value;for(const e in t)if(i(t,e)&&t[e].dirty.value){s=!0;break}this._dirty.value=s})}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function g(a,s,t){const e=_(a);return new v(e,s,t)}function E(a,s,t){const e=a.map(r=>d(r));return new C(e,s,t)}function S(a,s,t){return new h(a,s,t)}function _(a){const s={};return Object.keys(a).forEach(t=>{s[t]=d(a[t])}),s}function d(a){if(y(a))return a;if(Array.isArray(a)){const[t,e,r]=a;return new h(t,e,r)}const s=_(a);return new v(s)}export{g as a,S as b,E as u};

import{d as N,S as F,c as P,b as q,r as Q,w as W,au as G}from"./vendor-fe119cfa.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function U(d,a,o,u="pre"){const v=(l,r)=>{for(let M=0;M<l.length;M++){const p=l[M];u==="pre"&&o(p,r),p[a]&&v(p[a],[p,...r]),u==="post"&&o(p,r)}};v(d,[])}function Z(d,a,o){const u=(v,l)=>{const r=[];for(let M=0;M<v.length;M++){const p=v[M],h=o(p,l,M);if(h){if(p[a]){const g=u(p[a],[p,...l]);h[a]=g}r.push(h)}}return r};return u(d,[])}function X(d,a,o,u="or"){const v=(l,r)=>{var p;const M=[];for(let h=0;h<l.length;h++){let g;const E=l[h];E[a]&&(g=v(E[a],[E,...r]));let k=o(E,r,g);const x=g&&g.length>0||!((p=E[a])!=null&&p.length)&&k;k=u==="and"?x&&k:x||k,k&&M.push({...E,[a]:E[a]&&g})}return M};return v(d,[])}function j(d,a,o,u){var l;const v=d.map(r=>({...r}));for(const r of a){const M=v.find(p=>{const h=u(r),g=u(p);return!N(h)&&!N(g)&&h===g});if(!M){v.push({...r});continue}for(const p of[...Object.getOwnPropertyNames(r),...Object.getOwnPropertySymbols(r)])p!==o&&(M[p]=r[p]);F(r[o])&&(M[o]=j((l=M[o])!=null?l:[],r[o],o,u))}return v}function $(d,a,o,u=!1){const v=[];return U(d,a,l=>{if(!u||!l[a]||l[a].length<=0){const r=o?o(l):l;r&&v.push(r)}}),v}function B(d,a,o,u=!1){const v=[];return U(d,a,l=>{var r;(!u||!((r=l[a])!=null&&r.length))&&v.push(o(l))}),v}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function H(d,a,o,u){const v=n=>F(n)?J(n,a.value,o.value):n,l=P(()=>{var n;return(n=u==null?void 0:u.value)!=null?n:"all"}),r=P(()=>v(d.value)),M=(n,f)=>{const{parentKeyMap:A,dataMap:i}=f,e=[];let s=n;for(;A.has(s);){const c=A.get(s),t=i.get(c);t&&e.push(t),s=c}return e},p=()=>{const{data:n,parentKeyMap:f,dataMap:A}=r.value;if(n)return n;const i=[];for(const e of f.keys())!f.has(e)&&A.has(e)&&i.push(A.get(e));return i},h=(n,f,A)=>{if(!f.length)return Array.from(n);if(l.value==="off")return Array.from(new Set([...n,...f]));const{dataMap:i}=A,e=new Set(n);return f.forEach(s=>{if(!i.has(s))return;const c=i.get(s);B([c],a.value,o.value,l.value==="child").forEach(t=>{e.add(t)})}),l.value==="child"?Array.from(e).filter(s=>{var c,t;return!((t=(c=i.get(s))==null?void 0:c[a.value])!=null&&t.length)}):(f.forEach(s=>{M(s,A).forEach(c=>{var t;(t=c[a.value])!=null&&t.every(m=>e.has(o.value(m)))&&e.add(o.value(c))})}),l.value==="all"||e.forEach(s=>{var t;if(!e.has(s))return;const c=(t=i.get(s))==null?void 0:t[a.value];c&&U(c,a.value,m=>{e.delete(o.value(m))})}),Array.from(e))},g=(n,f,A)=>{if(!f.length)return Array.from(n);const i=new Set(n);if(l.value==="off")return f.forEach(t=>{i.delete(t)}),Array.from(i);const{dataMap:e}=A,s=new Set,c=t=>{s.add(t),i.delete(t)};return f.forEach(t=>{if(!e.has(t))return;B([e.get(t)],a.value,o.value).forEach(w=>{c(w)});const m=M(t,A);if(l.value==="parent"){const C=[t,...m.map(o.value)].findIndex(I=>i.has(I));C>-1&&m.slice(0,C).forEach(I=>{I[a.value]&&(I[a.value].forEach(_=>{const S=o.value(_);s.has(S)||i.add(S)}),c(o.value(I)))})}else m.forEach(w=>{c(o.value(w))})}),Array.from(i)},E=(n,f)=>h(n,f,r.value),k=(n,f)=>g(n,f,r.value),x=(n,f)=>{const A=n!=null?n:p(),i=l.value==="parent"?A.map(o.value):new Set(B(A,a.value,o.value,l.value==="child"));return g(i,f,n?v(n):r.value)},T=(n,f)=>h([],f,n?v(n):r.value);return{appendKeys:E,removeKeys:k,getAllCheckedKeys:(n,f)=>{const A=(i=>q(i==null?void 0:i[0]))(n);return x(A?n:void 0,f!=null?f:A?[]:n!=null?n:[])},getAllUncheckedKeys:(n,f)=>{const A=(i=>q(i==null?void 0:i[0]))(n);return T(A?n:void 0,f!=null?f:A?[]:n!=null?n:[])}}}function J(d,a,o){const u=new Map,v=new Map,l=new Map;return U(d,a,(r,M)=>{const p=o(r),h=M[0];u.set(p,r),l.set(p,M.length),h&&v.set(p,o(h))}),{data:d,dataMap:u,parentKeyMap:v,depthMap:l}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function y(d,a,o,u,v,l){const r=Q([]),M=P(()=>J(r.value,o.value,u.value)),p=P(()=>{const{data:e,dataMap:s,parentKeyMap:c,depthMap:t}=a.value,{data:m,dataMap:w,parentKeyMap:C,depthMap:I}=M.value,_=j(e!=null?e:[],m!=null?m:[],o.value,u.value),S=new Map(s);S.forEach((z,b)=>{if(w.has(b)){const O=w.get(b);S.set(b,j([z],[O],o.value,u.value)[0]),w.delete(b)}}),w.forEach((z,b)=>{S.set(b,z)});const R=new Map([...C,...c]),L=new Map([...I,...t]);return{data:_,dataMap:S,parentKeyMap:R,depthMap:L}}),h=H(p,o,u,v),g=H(p,o,u,P(()=>"all")),E=P(()=>{const{dataMap:e}=p.value,s=new Set;return e.forEach((c,t)=>{var m;(m=l.value)!=null&&m.call(l,c)&&s.add(t)}),s}),k=P(()=>{const e=v.value==="off"?d.value:g.appendKeys([],d.value);return new Set(e)}),x=P(()=>{const{parentKeyMap:e}=p.value,s=k.value;if(s.size===0||v.value==="off")return new Set;const c=new Set;return s.forEach(t=>{let m=e.get(t);if(!N(m)&&!s.has(m))for(;!N(m);)c.add(m),m=e.get(m)}),c});W([d,v],()=>{const{data:e}=p.value,s=k.value;r.value=X(e,o.value,c=>s.has(u.value(c)),"or")});const T=e=>E.value.has(e),D=e=>k.value.has(e),V=e=>x.value.has(e),n=e=>{var _;const s=u.value(e);if(T(s))return{checked:D(s),checkedKeys:d.value};const c=v.value!=="off"?(_=e[o.value])!=null?_:[]:[],t=D(s)||!!c.length&&c.every(S=>{const R=u.value(S);return D(R)||V(R)||T(R)}),m=h.appendKeys([],d.value),w=h[t?"removeKeys":"appendKeys"](m,[s]),C=t?[...k.value].filter(S=>T(S)):(v.value==="parent"?g.appendKeys([],w):w).filter(S=>T(S)&&!k.value.has(S)),I=h[t?"appendKeys":"removeKeys"](w,C);return{checked:!t,checkedKeys:I}},f=(e,s,c)=>{var I;const t=(_=>F(_)&&q(_==null?void 0:_[0]))(e),m=(I=t?G(s)?[]:s:e)!=null?I:[],w=t?G(s)?s:c:void 0,C=t?w?j(e,r.value,o.value,u.value):e:[];return{dataProvided:t,data:C,defaultKeys:m,cached:w}};return{allCheckedKeySet:k,checkDisabledKeySet:E,checkStateResolver:h,isChecked:D,isCheckDisabled:T,isIndeterminate:V,toggle:n,getAllCheckedKeys:(e,s,c)=>{const t=f(e,s,c);return t.dataProvided?h.getAllCheckedKeys(t.data,t.defaultKeys):h.getAllCheckedKeys(t.defaultKeys)},getAllUncheckedKeys:(e,s,c)=>{const t=f(e,s,c);return t.dataProvided?h.getAllUncheckedKeys(t.data,t.defaultKeys):h.getAllCheckedKeys(t.defaultKeys)}}}export{H as a,j as b,$ as c,X as f,B as g,Z as m,U as t,y as u};

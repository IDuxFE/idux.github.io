import{aX as G,b0 as B,b1 as j,q as L}from"./index-57842767.js";import{c as T,k as H,b as q,d as z,s as U,w as F,ah as N}from"./vendor-95ed6e76.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function X(S,p,c,f){const M=e=>H(e)?J(e,p.value,c.value):e,h=T(()=>{var e;return(e=f==null?void 0:f.value)!=null?e:"all"}),w=T(()=>M(S.value)),A=(e,o)=>{const{parentKeyMap:r,dataMap:l}=o,u=[];let g=e;for(;r.has(g);){const a=r.get(g),t=l.get(a);t&&u.push(t),g=a}return u},i=()=>{const{data:e,parentKeyMap:o,dataMap:r}=w.value;if(e)return e;const l=[];for(const u of o.keys())!o.has(u)&&r.has(u)&&l.push(r.get(u));return l},_=(e,o,r)=>{if(!o.length)return Array.from(e);if(h.value==="off")return Array.from(new Set([...e,...o]));const{dataMap:l}=r,u=new Set(e),g=new Set;return o.forEach(a=>{if(!l.has(a)||u.has(a))return;const n=l.get(a)[p.value];u.add(a),g.add(a),n!=null&&n.length&&B(n,p.value,c.value,h.value==="child").forEach(s=>{u.add(s),g.delete(s)})}),h.value==="child"?Array.from(u).filter(a=>{var t,n;return!((n=(t=l.get(a))==null?void 0:t[p.value])!=null&&n.length)}):(g.forEach(a=>{A(a,r).forEach(t=>{var n;(n=t[p.value])!=null&&n.every(s=>u.has(c.value(s)))&&u.add(c.value(t))})}),h.value==="all"||u.forEach(a=>{var n;if(!u.has(a))return;const t=(n=l.get(a))==null?void 0:n[p.value];t&&G(t,p.value,s=>{u.delete(c.value(s))})}),Array.from(u))},E=(e,o,r)=>{if(!o.length)return Array.from(e);const l=new Set(e);if(h.value==="off")return o.forEach(t=>{l.delete(t)}),Array.from(l);const{dataMap:u}=r,g=new Set,a=t=>{g.add(t),l.delete(t)};return o.forEach(t=>{if(!u.has(t))return;B([u.get(t)],p.value,c.value).forEach(s=>{a(s)});const n=A(t,r);if(h.value==="parent"){const v=[t,...n.map(c.value)].findIndex(d=>l.has(d));v>-1&&n.slice(0,v).forEach(d=>{d[p.value]&&(d[p.value].forEach(k=>{const R=c.value(k);g.has(R)||l.add(R)}),a(c.value(d)))})}else n.forEach(s=>{a(c.value(s))})}),Array.from(l)},y=(e,o)=>_(e,o,w.value),P=(e,o)=>E(e,o,w.value),I=(e,o)=>{const r=e!=null?e:i(),l=h.value==="parent"?r.map(c.value):new Set(B(r,p.value,c.value,h.value==="child"));return E(l,o,e?M(e):w.value)},D=(e,o)=>_([],o,e?M(e):w.value);return{appendKeys:y,removeKeys:P,getAllCheckedKeys:(e,o)=>{const r=(l=>q(l==null?void 0:l[0]))(e);return I(r?e:void 0,o!=null?o:r?[]:e!=null?e:[])},getAllUncheckedKeys:(e,o)=>{const r=(l=>q(l==null?void 0:l[0]))(e);return D(r?e:void 0,o!=null?o:r?[]:e!=null?e:[])}}}function J(S,p,c){const f=new Map,M=new Map,h=new Map;return G(S,p,(w,A)=>{const i=c(w),_=A[0];f.set(i,w),h.set(i,A.length),_&&M.set(i,c(_))}),{data:S,dataMap:f,parentKeyMap:M,depthMap:h}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Y(S,p,c,f,M,h){const{mergedResolverContext:w,cachedSelectedData:A,checkStateResolver:i,allCheckStateResolver:_,allCheckedKeySet:E,unexistedKeys:y}=Q(S,p,c,f,M),P=T(()=>{const{dataMap:a}=w.value,t=new Set;return a.forEach((n,s)=>{var v;(v=h.value)!=null&&v.call(h,n)&&t.add(s)}),t}),I=T(()=>{const{parentKeyMap:a}=w.value,t=E.value;if(t.size===0||M.value==="off")return new Set;const n=new Set;return t.forEach(s=>{let v=a.get(s);if(!z(v)&&!t.has(v))for(;!z(v);)n.add(v),v=a.get(v)}),n}),D=a=>P.value.has(a),m=a=>E.value.has(a),C=a=>I.value.has(a),e=a=>y.value?[...a,...y.value]:a,o=a=>{var K;const t=f.value(a);if(D(t))return{checked:m(t),checkedKeys:S.value};const n=M.value!=="off"?(K=a[c.value])!=null?K:[]:[],s=m(t)||!!n.length&&n.every(x=>{const b=f.value(x);return m(b)||C(b)||D(b)}),v=i.appendKeys([],S.value),d=i[s?"removeKeys":"appendKeys"](v,[t]),k=s?[...E.value].filter(x=>D(x)):(M.value==="parent"?_.appendKeys([],d):d).filter(x=>D(x)&&!E.value.has(x)),R=e(i[s?"appendKeys":"removeKeys"](d,k));return{checked:!s,checkedKeys:R}},r=(a,t,n)=>{var R;const s=(K=>H(K)&&q(K==null?void 0:K[0]))(a),v=(R=s?N(t)?[]:t:a)!=null?R:[],d=s?N(t)?t:n:void 0,k=s?d?j(a,A.value,c.value,f.value):a:[];return{dataProvided:s,data:k,defaultKeys:v,cached:d}};return{allCheckedKeySet:E,checkDisabledKeySet:P,checkStateResolver:i,isChecked:m,isCheckDisabled:D,isIndeterminate:C,toggle:o,getAllCheckedKeys:(a,t,n)=>{const s=r(a,t,n),v=s.dataProvided?i.getAllCheckedKeys(s.data,s.defaultKeys):i.getAllCheckedKeys(s.defaultKeys);return e(v)},getAllUncheckedKeys:(a,t,n)=>{const s=r(a,t,n);return s.dataProvided?i.getAllUncheckedKeys(s.data,s.defaultKeys):i.getAllCheckedKeys(s.defaultKeys)},getDataByKeys:a=>{const{dataMap:t}=w.value;return a.map(n=>t.get(n)).filter(Boolean)}}}function Q(S,p,c,f,M){const h=U([]),w=T(()=>J(h.value,c.value,f.value)),A=U(p.value),i=U(new Set),_={value:[]},E=X(A,c,f,M),y=X(A,c,f,T(()=>"all")),P=()=>{const{data:m,dataMap:C,parentKeyMap:e,depthMap:o}=p.value,{data:r,dataMap:l,parentKeyMap:u,depthMap:g}=w.value,a=j(m!=null?m:[],r!=null?r:[],c.value,f.value),t=new Map(C),n=new Map(l);t.forEach((d,k)=>{if(n.has(k)){const R=n.get(k);t.set(k,j([d],[R],c.value,f.value)[0]),n.delete(k)}}),n.forEach((d,k)=>{t.set(k,d)});const s=new Map([...u,...e]),v=new Map([...g,...o]);A.value={data:a,dataMap:t,parentKeyMap:s,depthMap:v}},I=()=>{const{data:m}=A.value,C=i.value;h.value=L(m!=null?m:[],c.value,e=>C.has(f.value(e)),"or")},D=()=>{const m=M.value==="off"?S.value:y.appendKeys([],S.value),C=new Set(m);i.value=C;const e=S.value.filter(o=>!C.has(o));e.length!==_.value.length&&I(),_.value=e};return F(p,P),F([S,A,M],D,{immediate:!0}),{mergedResolverContext:A,cachedSelectedData:h,checkStateResolver:E,allCheckStateResolver:y,allCheckedKeySet:i,unexistedKeys:_}}export{X as a,Y as u};

import{aX as G,b0 as b,b1 as j,q as L}from"./index-65f16f37.js";import{c as T,k as H,b as q,d as z,s as B,w as F,ah as N}from"./vendor-97d35b92.js";/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function X(S,p,c,f){const M=e=>H(e)?J(e,p.value,c.value):e,h=T(()=>{var e;return(e=f==null?void 0:f.value)!=null?e:"all"}),w=T(()=>M(S.value)),A=(e,l)=>{const{parentKeyMap:r,dataMap:o}=l,u=[];let g=e;for(;r.has(g);){const a=r.get(g),t=o.get(a);t&&u.push(t),g=a}return u},d=()=>{const{data:e,parentKeyMap:l,dataMap:r}=w.value;if(e)return e;const o=[];for(const u of l.keys())!l.has(u)&&r.has(u)&&o.push(r.get(u));return o},_=(e,l,r)=>{if(!l.length)return Array.from(e);if(h.value==="off")return Array.from(new Set([...e,...l]));const{dataMap:o}=r,u=new Set(e),g=new Set;return l.forEach(a=>{if(!o.has(a)||u.has(a))return;const n=o.get(a)[p.value];u.add(a),g.add(a),n!=null&&n.length&&b(n,p.value,c.value,h.value==="child").forEach(s=>{u.add(s),g.delete(s)})}),h.value==="child"?Array.from(u).filter(a=>{var t,n;return!((n=(t=o.get(a))==null?void 0:t[p.value])!=null&&n.length)}):(g.forEach(a=>{A(a,r).forEach(t=>{var n;(n=t[p.value])!=null&&n.every(s=>u.has(c.value(s)))&&u.add(c.value(t))})}),h.value==="all"||u.forEach(a=>{var n;if(!u.has(a))return;const t=(n=o.get(a))==null?void 0:n[p.value];t&&G(t,p.value,s=>{u.delete(c.value(s))})}),Array.from(u))},E=(e,l,r)=>{if(!l.length)return Array.from(e);const o=new Set(e);if(h.value==="off")return l.forEach(t=>{o.delete(t)}),Array.from(o);const{dataMap:u}=r,g=new Set,a=t=>{g.add(t),o.delete(t)};return l.forEach(t=>{if(!u.has(t))return;b([u.get(t)],p.value,c.value).forEach(s=>{a(s)});const n=A(t,r);if(h.value==="parent"){const v=[t,...n.map(c.value)].findIndex(i=>o.has(i));v>-1&&n.slice(0,v).forEach(i=>{i[p.value]&&(i[p.value].forEach(k=>{const y=c.value(k);g.has(y)||o.add(y)}),a(c.value(i)))})}else n.forEach(s=>{a(c.value(s))})}),Array.from(o)},K=(e,l)=>_(e,l,w.value),P=(e,l)=>E(e,l,w.value),I=(e,l)=>{const r=e!=null?e:d(),o=h.value==="parent"?r.map(c.value):new Set(b(r,p.value,c.value,h.value==="child"));return E(o,l,e?M(e):w.value)},D=(e,l)=>_([],l,e?M(e):w.value);return{appendKeys:K,removeKeys:P,getAllCheckedKeys:(e,l)=>{const r=(o=>q(o==null?void 0:o[0]))(e);return I(r?e:void 0,l!=null?l:r?[]:e!=null?e:[])},getAllUncheckedKeys:(e,l)=>{const r=(o=>q(o==null?void 0:o[0]))(e);return D(r?e:void 0,l!=null?l:r?[]:e!=null?e:[])}}}function J(S,p,c){const f=new Map,M=new Map,h=new Map;return G(S,p,(w,A)=>{const d=c(w),_=A[0];f.set(d,w),h.set(d,A.length),_&&M.set(d,c(_))}),{data:S,dataMap:f,parentKeyMap:M,depthMap:h}}/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/IDuxFE/idux/blob/main/LICENSE
 */function Y(S,p,c,f,M,h){const{mergedResolverContext:w,cachedSelectedData:A,checkStateResolver:d,allCheckStateResolver:_,allCheckedKeySet:E,unexistedKeys:K}=Q(S,p,c,f,M),P=T(()=>{const{dataMap:a}=w.value,t=new Set;return a.forEach((n,s)=>{var v;(v=h.value)!=null&&v.call(h,n)&&t.add(s)}),t}),I=T(()=>{const{parentKeyMap:a}=w.value,t=E.value;if(t.size===0||M.value==="off")return new Set;const n=new Set;return t.forEach(s=>{let v=a.get(s);if(!z(v)&&!t.has(v))for(;!z(v);)n.add(v),v=a.get(v)}),n}),D=a=>P.value.has(a),m=a=>E.value.has(a),C=a=>I.value.has(a),e=a=>K.value?[...a,...K.value]:a,l=a=>{var R;const t=f.value(a);if(D(t))return{checked:m(t),checkedKeys:S.value};const n=M.value!=="off"?(R=a[c.value])!=null?R:[]:[],s=m(t)||!!n.length&&n.every(x=>{const U=f.value(x);return m(U)||C(U)||D(U)}),v=d.appendKeys([],S.value),i=d[s?"removeKeys":"appendKeys"](v,[t]),k=s?[...E.value].filter(x=>D(x)):(M.value==="parent"?_.appendKeys([],i):i).filter(x=>D(x)&&!E.value.has(x)),y=e(d[s?"appendKeys":"removeKeys"](i,k));return{checked:!s,checkedKeys:y}},r=(a,t,n)=>{var y;const s=(R=>H(R)&&q(R==null?void 0:R[0]))(a),v=(y=s?N(t)?[]:t:a)!=null?y:[],i=s?N(t)?t:n:void 0,k=s?i?j(a,A.value,c.value,f.value):a:[];return{dataProvided:s,data:k,defaultKeys:v,cached:i}};return{allCheckedKeySet:E,checkDisabledKeySet:P,checkStateResolver:d,isChecked:m,isCheckDisabled:D,isIndeterminate:C,toggle:l,getAllCheckedKeys:(a,t,n)=>{const s=r(a,t,n),v=s.dataProvided?d.getAllCheckedKeys(s.data,s.defaultKeys):d.getAllCheckedKeys(s.defaultKeys);return e(v)},getAllUncheckedKeys:(a,t,n)=>{const s=r(a,t,n),v=s.dataProvided?d.getAllUncheckedKeys(s.data,s.defaultKeys):d.getAllUncheckedKeys(s.defaultKeys);return e(v)},getDataByKeys:a=>{const{dataMap:t}=w.value;return a.map(n=>t.get(n)).filter(Boolean)}}}function Q(S,p,c,f,M){const h=B([]),w=T(()=>J(h.value,c.value,f.value)),A=B(p.value),d=B(new Set),_={value:[]},E=X(A,c,f,M),K=X(A,c,f,T(()=>"all")),P=()=>{const{data:m,dataMap:C,parentKeyMap:e,depthMap:l}=p.value,{data:r,dataMap:o,parentKeyMap:u,depthMap:g}=w.value,a=j(m!=null?m:[],r!=null?r:[],c.value,f.value),t=new Map(C),n=new Map(o);t.forEach((i,k)=>{if(n.has(k)){const y=n.get(k);t.set(k,j([i],[y],c.value,f.value)[0]),n.delete(k)}}),n.forEach((i,k)=>{t.set(k,i)});const s=new Map([...u,...e]),v=new Map([...g,...l]);A.value={data:a,dataMap:t,parentKeyMap:s,depthMap:v}},I=()=>{const{data:m}=A.value,C=d.value;h.value=L(m!=null?m:[],c.value,e=>C.has(f.value(e)),"or")},D=()=>{const m=M.value==="off"?S.value:K.appendKeys([],S.value),C=new Set(m);d.value=C;const e=S.value.filter(l=>!C.has(l));e.length!==_.value.length&&I(),_.value=e};return F(p,P),F([S,A,M],D,{immediate:!0}),{mergedResolverContext:A,cachedSelectedData:h,checkStateResolver:E,allCheckStateResolver:K,allCheckedKeySet:d,unexistedKeys:_}}export{X as a,Y as u};
